# KeysManager

LDK provides a simple default ```KeysManager``` implementation which provides key management and signing oprations for a Lightning node. For developers that would like to customize the way key material and entropy are sourced, LDK provides `NodeSigner`, `SignerProvider`, and `EntropySource` traits for developers to implement. The `KeysManager` provides default implementations for each of these traits.

To instantiate a ```KeysManager```, we simply provide a 32-byte `seed` and some random integers (to ensure uniqueness across restarts). The  ```KeysManager``` will use the `seed` as a BIP 32 extended key and derive all keys from that.

```rust
pub struct KeysManager {
  secp_ctx: Secp256k1<secp256k1::All>,
  node_secret: SecretKey,
  node_id: PublicKey,
  inbound_payment_key: KeyMaterial,
  destination_script: ScriptBuf,
  shutdown_pubkey: PublicKey,
  channel_master_key: Xpriv,
  channel_child_index: AtomicUsize,
  entropy_source: RandomBytes,
  seed: [u8; 32],
  starting_time_secs: u64,
  starting_time_nanos: u32,
}
```

## Important KeysManager Functionality
1. **Node Operations** (via `NodeSigner`)
   - Node identification
   - Invoice signing
   - Message encryption (ECDH)
   - Gossip message signing

2. **Channel Operations** (via `SignerProvider` & `ChannelSigner`)
   - Derives unique signers for each channel
   - Manages channel funding keys
   - Handles commitment transaction signing
   - Manages revocation keys

3. **On-chain Operations**
   - Manages destination scripts for receiving funds
   - Handles channel closure transactions
   - Signs justice transactions


## Creating A Unified (On-Chain + Off-Chain) Wallet
LDK makes it simple to combine an on-chain and off-chain wallet within the same app.

#### Question: What are best practices when combining an on-chain and off-chain wallet within the same application?

<details>
  <summary>
    Answer
</summary>
When combining an on-chain and off-chain wallet in the same application, it's reccomended to derive your initial LDK seed from a hardened path. The advantages to this approach are that you do not need to worry about storing two different recovery phrases and, if your lightning keys were compromised, your on-chain funds are not at risk.
</details>

### ⚡️ Build A Unified Wallet

Complete `unified_onchain_offchain_wallet` in `src/ch3_keys/exercises.rs`.

```rust
pub fn unified_onchain_offchain_wallet(seed: [u8; 64]) -> KeysManager {
}

```

This function will take the seed to a separate on-chain wallet and return an LDK `KeysManager` by calling the [`KeysManager::new` constructor](https://docs.rs/lightning/latest/lightning/sign/struct.KeysManager.html#method.new).

However, to ensure that our ldk wallet is separate from our on-chain wallet, we'll derive a hardened private key from `m/535` and use this as our starting entropy for our wallet. **Make sure to use `m/535` as your hardened path! Otherwise, your function won't pass the automated test in this workbook.**

If you would like a hint, click below.


<details>
  <summary>
    Hint
</summary>
When combining an on-chain and off-chain wallet in the same application, it's reccomended to derive your initial LDK seed from a hardened path. The advantages to this approach are that you do not need to worry about storing two different recovery phrases and, if your lightning keys were compromised, your on-chain funds are not at risk.
</details>
