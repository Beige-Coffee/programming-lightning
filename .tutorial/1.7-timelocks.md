# Timelocks

Timelocks are a neat feature in Bitcoin that allow us to lock bitcoin such that they can only be spent after a certain amount of time passes. For example, we can lock bitcoin so that they can only be spent after 144 blocks from when they are mined. Or, we can accidentally lock them  forever - fun!

There are multiple ways to specify time-based conditions on our transactions. Generally speaking, timelocks can either be **relative** or **absolute**.
- A **relative** timelock will lock bitcoin until either a certain number of blocks or seconds have passed since the input or output is first mined in a block. For example, if I add a relative timlock of 144 blocks to an output, then that output is only spendable 144 blocks (~1 day) *after* it is first mined within a block.
- An **absolute** timelock will lock bitcoin until either a given **block height** or **unix timestamp** is reached. For example, if I timelock an output to block height 2,000,000, then the output cannot be spent until after block 2,000,000.

Timelock conditions can be placed in the following three locations within a transaction:
- **```nLocktime```**: This is a **transaction level** timelock that locks the entire transaction to an **absolute** timelock. If a timelock condition is placed in this field, then the transaction itself cannot be mined until **after** a specific block height or time has passed.

- **```nSequence```**: This is an **input level** timelock that locks an input to a **relative** timelock. If a timelock condition is placed on an input, then the input cannot be spent until that **amount of blocks or time has passed since the output it's referencing was mined**. Therefore, this input is only able to be mined after that time period has passed! It's also important to note that the ```nSquence``` field plays a par

- **```scriptPubKey```**: Using the script programming language, you can lock **outputs** with both a **relative** and **absolute** timelock. This ensures that the outputs cannot be spent until either the block height (or timestamp) has been reached or that the outputs cannot be spent until the specified number of block (or seconds) have passed.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/TXLocktimes.png" alt="TXLocktimes" width="90%" height="auto">
</p>

The **```nSequence```** field is quite important when configuring locktimes, so let's take a closer look at it.
- To enable **```nLocktime```** to be used on a transaction, we need to configure the **```nSequence```** for at least one input to be `0xFFFFFFFE` or less.
- To enable **Replace By Fee**, we need to configure the **```nSequence```** for at least one input to be `0xFFFFFFFD` or less.
- To enable **Relative Locktime**, we need to configure the **```nSequence```** to be:
  - **`0x00000000`** to **`0x0000FFFF`**
  - **`0x00400000`** to **`0x0040FFFF`**
  
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/nsequence.png" alt="nsequence" width="90%" height="auto">
</p>

### Evaluating OP_CSV & OP_CLTV
This may be surprising, but Bitcoin does not check if OP_CSV or OP_CLTV conditions are satisfied directly. Instead, the Bitcoin protocol will reference other parts of the transaction and rely on other transactions rules to enforce the timelock conditions. 
- `OP_CSV` is enforced by referencing the `nSequence` value. For example, if our locking script was `... 144 OP_CSV OP_DROP`, then this output should not be spendable until 144 blocks have passed since it's parent transaction was mined. To enforce this rule, Bitcoin will check the `nSequence` value, because `nSequence` already enforces the rule that the input cannot be mined until *x* number of blocks have passed since the parent transaction was mined. Therefore, if the timelock in the locking script is >= the `nSequence`, we know that amount of time has passed.
- `OP_CLTV` is enforced by referencing the `nLocktime` value. Similar to above, per Bitcoin consensus rules, a transaction cannot be mined if its `nLocktime` has not passed. Therefore, we can enforce the absolute locktime in an `OP_CLTV` script by checking to see if the block height or timestamp is >= the the `nLocktime` value.
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/TimelockVerification.png" alt="TimelockVerification" width="90%" height="auto">
</p>

<br/>

<details>
  <summary>Click to view how timelock conditions are processed by the Bitcoin protocol!</summary>

Timelock conditions are processed as follows:
- **```nLocktime```**:
  - If ```nLocktime``` is set to ```<=499999999```, then the ```nLocktime``` field is read as a **block height**.
  - If ```nLocktime``` is set to ```>=500000000```, then the ```nLocktime``` field is read as a **timestamp**.

- **```nSquence```**:
  - If ```nSquence``` is set to ```0x00000000 to 0x0000FFFF```, then ```nSquence``` is read as the **number of blocks**.
  - If ```nSquence``` is set to ```0x00400000 to 0x0040FFFF```, then ```nSquence``` is read as the **number of seconds**.

- **```scriptPubKey```**:
  - To lock the output to an **absolute** block height or timestamp, you would, generally, use the following script: ```<blockheight_or_timestamp> OP_CLTV OP_DROP```
  - To lock the output to a **relative** number of blocks or seconds, you would, generally, use the following script: ```<blockheight_or_timestamp> OP_CSV OP_DROP```
  - It's worth mentioning that both scripts are preceded by ```OP_DROP``` because they both leave whichever item they are checking (block height or timestamp) on the stack after the evaluation, so we need to drop (or remove) it with ```OP_DROP``` before moving on to the rest of the script.

</details>


## ⚡️ Generate a Timelocked Transaction

For this exercise, we'll generate a timelocked output, mine the transaction in our regtest environment, and then spend the timelocked output! To do this, we need to complete the following steps:
1) We'll build a **relative timelocked** script which locks our output to the hash of a public key.
2) We'll create a new transaction that spends from the timelocked output. Crucially, we'll need to ensure we build our **input** is constructed in such a way that it allows for our relative timelock to be validated.

#### Exercise #1: Create P2PKH Output Script

We'll start this exercise by completing the ```csv_p2pkh``` function in the ```lib.rs```. This function will take a ```PublicKey``` and ```height_or_timestamp``` as an input and produce a CSV locked P2PKH output script.

<details>
  <summary>Click here to see the output script</summary>
  
`<blockheight_or_timestamp> OP_CLTV OP_DROP OP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG`

</details>

```rust
fn csv_p2pkh(pubkey: &PublicKey, height_or_timestamp: i64) -> ScriptBuf {
}
```

#### Exercise #2: Build Transaction

Now, let's complete the ```build_timelocked_transaction``` function. This function will take a ```txins``` structs (transaction inputs), ```PublicKey```,  ```block_height``` (nLocktime), ```csv_delay```, and ```amount```. You can use the functions you created in the previous exercises to help. Comments have been provided below to guide you.

The below tips will help you as you complete the exercise:
- The ```version``` field in ```Transaction``` expects a ```Version``` structure. You can use ```Version::ONE``` for legacy transactions and ```Version::TWO``` for SegWit. This exercise invovles building a legacy transaction.
- The ```lock_time``` field expects a ```Locktime``` structure. This structure has a method ```LockTime::from_height()```, which can be used to create an absolute block height locktime.
- The ```output``` field expects a ```vec``` data type. you can wrap your output in ```vec![ output ]``` to satisfy this expectation. That same is true for ```input```, but that is provided as part of this function, so you don't have to worry about that.

```rust
fn build_timelocked_transaction(
    txins: Vec<TxIn>,
    pubkey: &PublicKey,
    block_height: u64,
    csv_delay: u32,
    amount: Amount,
) -> Transaction {

    // step 1. create csv p2pkh output script

    // step 2. create txout

    // step 3. create transaction
}
```

<details>
  <summary>Click here for a hint if you get stuck</summary>

```rust
fn build_timelocked_transaction(
    txins: Vec<TxIn>,
    pubkey: &PublicKey,
    block_height: u64,
    csv_delay: u32,
    amount: Amount,
) -> Transaction {

    // step 1. create csv p2pkh output script

    // step 2. create txout

    // step 3. create transaction
    Transaction {
        version: // version here,
        lock_time: // locktime here,
        input: // txins here,
        output: vec![// txout here
                    ],
    }
}
```
</details>

## ⚡️ Broadcast Timelocked Transaction

Once you've completed `build_timelocked_transaction` and passed the tests, go over to `src/bin/timelock.rs`. Once there, you should see the below code.

Go ahead and define a transaction timelock for the `block_height` and a CSV delay for `csv_delay`. Once you've done this, add the relevant parameters to the `build_timelocked_transaction` function.

```rust
pub async fn create_timelock_tx(bitcoind: BitcoindClient,
                                         utxo: ListUnspentUtxo,
                                        tx_input: TxIn,
                                        tx_in_amount: u64) {

    // get a public key to lock funds to
    let our_public_key = secp256k1_pubkey_from_private_key(&[0x01; 32]);
    // define a block height for which the transaction is valid
    let block_height: u32 = // add block height here
    // define a csv delay for the output
    let csv_delay: i64 = // add csv here

    // build funding transaction using the function we created
    let tx = build_timelocked_transaction(
        // add parameters
        );

    let signed_tx = sign_raw_transaction(bitcoind.clone(), tx).await;


    println!("Tx Hex: {}", serialize_hex(&signed_tx));
}
```

Finally, run `cargo run --bin timelock` in your **Shell**. The program should run, and you should see something like this below:

```
Tx Hex: 01000000000101723b03a221891a61df89b290f02c9965c5e402eb68b6c8c3fdc7a147e87bb39d01000000000000000001784a4c0000000000220020d98b2999c14402aa53158119355783520e05b0335427281ff5a090622baafb900247304402207fea5067da240db789369c69474da0a6c8b38e5a8ad25c94a5dd0a0c6d01c10b02204795db0f33a4f662fbe6314d97452115cc8ec161cdadb0bcaa3e9b2aa58882f00121035c02024a585f70b13fa87c67f41348b46f88d19b82d31e4b2e1141626e1fd646c8000000
```

This is the raw transaction hex. Try decoding and parsing the data with the following command: `bcli decoderawtransaction <raw tx>`.

Once you feel like you understand the transaction, go ahead and broadcast is using `bcli sendrawtransaction <raw tx>`.

Did everything work correctly? If so, you should see a TxID returned by the terminal.