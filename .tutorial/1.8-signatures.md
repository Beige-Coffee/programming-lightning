# Signatures

Up until this point, we've abstracted away most of the details behind bitcoin **signatures**. Before digging into Lightning, it's important to do a brief review of how signatures work, as they play an important role in creating a trustless off-chain payment system.

A **signature** accomplishes the following two goals:
1) It proves that you know the **secret key** to a corresponding **public key**.
2) It **binds itself** to specific information, such as a bitcoin transaction. This ensure that the signature is only valid for that particular piece of data, and it cannot be reused for another transaction.

## Creating a Signature
To create a signature, you need to *sign* a **message** using your private key. In Bitcoin, the message is the **transaction data**, but cryptographic signing can be leveraged for many things.

Recall, to unlock an input, we must provide a valid signature. Therefore, we must create a signature ***for each input*** that we'd like to spend.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/sign.png" alt="sign" width="50%" height="auto">
</p>

## Verifying a Signature
To verify a signature, we must have the following pieces of information:
- The **message** that was used to produce the signature.
- The **signature** itself.
- The **public key** corresponding to the *private key* that was used to create this messsage.

Then, by leveraging elliptic curve mathematics, we can do some advanced calculations to verify the following:
1) The person who created the signature knows the private key corresponding to the given public key.
2) The message itself has not changed in any meaningful way.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/verify.png" alt="verify" width="70%" height="auto">
</p>

## Signature Types
In Bitcoin, we can specify which parts of the transaction we're signing by adjusting the transaction data before passing it into the signing algorithm. This adds additional flexibility and capabilities, as participants can provide signatures to some parts of transactions, but not all.

To inform the Bitcoin protocol which parts of the transaction are being signed, we use a special **signature hash type** (also known as **sighash**) flag in our transaction. We do this by appending a **1-byte** sighash to the signature before including it in the transaction.

Below are the sighash options:

```
0x01 = SIGHASH_ALL
0x02 = SIGHASH_NONE
0x03 = SIGHASH_SINGLE
0x81 = SIGHASH_ALL | SIGHASH_ANYONECANPAY
0x82 = SIGHASH_NONE | SIGHASH_ANYONECANPAY
0x83 = SIGHASH_SINGLE | SIGHASH_ANYONECANPAY
```

We'll breifly discuss each of them below. When reviewing them, imagine we are spending the first input.

<p align="left" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/input.png" alt="input" width="30%" height="auto">
</p>


### SIGHASH_ALL & SIGHASH_ALL | SIGHASH_ANYONECANPAY
- The `SIGHASH_ALL` flag indicates that we signed **all of the inputs and outputs**. Therefore, for this signature to be valid, the inputs and ouputs cannot change.
- If `SIGHASH_ANYONECANPAY` is used in conjunction with the `SIGHASH_ALL` flag, then we are signaling that, for the given input we are seeking to spend, we only signed the input, but we still signed all of the outputs. 
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/sighash_all.png" alt="sighash_all" width="90%" height="auto">
</p>

### SIGHASH_NONE & SIGHASH_NONE | SIGHASH_ANYONECANPAY
- The `SIGHASH_NONE` flag indicates that we signed **all of the inputs and** ***none*** **of the outputs**. 
- If `SIGHASH_ANYONECANPAY` is used in conjunction with the `SIGHASH_NONE` flag, then we are signaling that, for the given input we are seeking to spend, we **only signed the input**. You pretty much never want to do this, as you are effectively providing a signature that allows for that input to be sent anywhere by anyone.
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/sighash_none.png" alt="sighash_none" width="90%" height="auto">
</p>

### SIGHASH_SINGLE & SIGHASH_SINGLE | SIGHASH_ANYONECANPAY
- The `SIGHASH_SINGLE` flag indicates that we signed **all of the inputs and** ***one*** **of the outputs**. The one output is the one that corresponds to the index of the input we're creating a signature for.
- If `SIGHASH_ANYONECANPAY` is used in conjunction with the `SIGHASH_SINGLE` flag, then we are signaling that, for the given input we are seeking to spend, we **only signed the input and the corresponding output**. This is useful if we want to allow *others* to replace by fee (RBF) our transaction with another one, as they would be able to attach their own inputs and outputs to the transaction in such a way that our signature is still valid.
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/sighash_single.png" alt="sighash_single" width="90%" height="auto">
</p>

## Segretated Witness (SegWit)

Segregated Witness, also known as "SegWit", was a soft-fork upgrade to Bitcoin that was activated in 2017. Why are we mentioning SegWit in this workshop? Well, SegWit was actually a crucial upgrade to Bitcoin and was required for the Lightning Network to work properly.

The SegWit upgrade moved the signature data from its previous location, the **scriptSig**, to a separate location, called the **witness stack**. After the upgrade, many SegWit transactions now leave the **scriptSig** blank or enter ```00```, indicating that there is no signature present for that input.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/SegWit.png" alt="SegWit" width="100%" height="auto">
</p>


## ⚡️ Generate A Signature

For this exercise, we'll complete the function `generate_p2wsh_signature`, which will create a P2WSH signature. Specifically, it will return a `Signature` type, which is defined in **rust-bitcoin**. You can read more about it [here](https://docs.rs/secp256k1/latest/secp256k1/ecdsa/struct.Signature.html).

```rust 
pub fn generate_p2wsh_signature(
    transaction: Transaction,
    input_idx: usize,
    witness_script: &ScriptBuf,
    value: Amount,
    sighash_type: EcdsaSighashType,
    private_key: secp256k1::SecretKey,
) -> Signature {
  let secp = Secp256k1::new();

  // TO DO
}
```

As we saw above, to generate a signature, we need to *sign* a **message** using our private key. To help in doing this, our function will take the following parameters:
- `transaction`: This is the transaction we wish to create a signature for.
- `input_idx`: This is the index of the input we're signing.
- `witness_script`: This is the script that defines the spending conditions for the input we're spending.
- `sighash_type`: This is the signature hash type we're using for the signature.
- `private_key`: This is the private key used to sign the message.

To complete this functionality, we'll want to implement the following steps:
1) **Create a message digest for our transaction and associated data**.
2) **Sign that message with out private keys**.

To help with the above task, the below function is available to you. This function will return a **message digest** that we can subsequently sign with our private key.

```rust 
fn generate_p2wsh_message(
    transaction: Transaction,
    input_idx: usize,
    witness_script: &ScriptBuf,
    value: Amount,
    sighash_type: EcdsaSighashType,
) -> Message
```

Within our `generate_p2wsh_signature` function, you'll notice that we already have the following code written: `let secp = Secp256k1::new();`. This code defines a variable, `scep`, which we can use to perform **secp256k1** curve operations. For example, we can call `secp.sign_ecdsa(&message, &private_key)` and pass in a *reference* (denoted by the *&* sign) to our message and private key. This will return the valid signature for us.
