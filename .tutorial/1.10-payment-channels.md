# Payment Channels

You can conceptually think of a payment channel as a way to perform batching of your payments over a potentially unlimited length of time. In fact, with a simple payment channel, two parties can make thousands of payments between each other while only ever making two on-chain bitcoin transactions. This reduces both the costs of sending transactions and the cost of storing transaction data, alleviating the three problems we identified earlier. 

## Core concept

So how is this possible? What is going on when payments are made in a payment channel?

The idea is that the two parties will still construct bitcoin transactions for each payment being made ***but they agree not to broadcast them to the chain***. By not broadcasting each transaction to the chain, the parties do not need to wait for confirmations, do not need to pay miner fees, and do not need to force resource costs onto the entire network.

Crucially, these transaction payments are considered "valid", because they contain all the appropriate signatures and conditions to be included in a block. However, channel partners ***choose*** not to broadcast them until they decide to (or need to) close the channel.

Like all good computer science textbooks, to help explain this concept, let's introduce our two old friends - Alice and Bob. Note that Alice and Bob each have their own private keys. Alice's private key is represented by a blue key, while Bob's private key is represented by a red key.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobKeys.png" alt="AliceBobKeys" width="60%" height="auto">
</p>

## Creating a Simple Payment Channel

To create a payment channel, Alice and Bob start by agreeing to fund a 2-of-2 multisig output with a specific amount. This amount is crucial, as it represents the total channel capacity, meaning Alice and Bob will only be able to transfer up to this amount between themselves.

To fund this channel, Alice and Bob create a **Pay-to-Witness-Script-Hash (P2WSH)** transaction that locks their channel balance into an output controlled by both of them. Specifically, this output requires both Alice and Bob to control one of the keys necessary to spend the funds. 


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/simple_funding.png" alt="simple_funding.png" width="100%" height="auto">
</p>

### Sending a Payment
Then, to send a payment Alice and Bob can simply create a new transaction that spends from the funding transaction. Each new transaction will have an output for Alice and Bob with their respective channel balances.
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/simple_payment.png" alt="simple_payment" width="100%" height="auto">
</p>

## ⚡️ Build A Payment Channel Funding Transaction

Complete `build_funding_transaction`. This function takes the following parameters:
- `txins`: A vector of transaction inputs (`Vec<TxIn>`).
- `alice_pubkey`: Alice's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `bob_pubkey`: Bob's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `amount`: The channel amount. This will be an unsigned 64-bit integer `u64` structure.

```rust
pub fn build_funding_transaction(
    txins: Vec<TxIn>,
    alice_pubkey: &PublicKey,
    bob_pubkey: &PublicKey,
    amount: Amount,
) -> Transaction {

  // build output script

  // build tx output
  //    note, we must call .to_p2wsh() on our witness (redeem) script
  //    to obtain the hash that goes in the output's scriptPubKey field

  // define version and locktime for transaction 

  // build transaction object
}
```

This transaction will return a `Transaction` structure, as defined by Rust Bitcoin.

```rust
pub struct Transaction {
    pub version: Version,
    pub lock_time: LockTime,
    pub input: Vec<TxIn>,
    pub output: Vec<TxOut>,
}
```

### To complete this exercise, we'll need to implement the following steps:

#### 1) Build a redeem script for our multisig.
<details>
  <summary>Step 1 Hint</summary>

Use the `two_of_two_multisig_redeem_script` function you created in an earlier exercise.

</details>

#### 2) Create an output (`TxOut` object) to be included in our funding transaction

<details>
  <summary>Step 2 Hint</summary>

A `build_output` function is available to you that takes an `amount` and `output_script` as an argument and produces a `TxOut` object that can be passed into a transaction.

**Note**: You will want to call `.to_p2wsh()` on your redeem script from step one either as you pass it in to `build_output` or before. This is because `.to_p2wsh()` will convert your redeem script into an output script! In other works, in the format `OP_0 <32 byte hash>`.

```rust
pub fn build_output(amount: u64, output_script: ScriptBuf) -> TxOut {
    
    TxOut {
        value: Amount::from_sat(amount),
        script_pubkey: output_script,
    }
}
```

</details>

#### 3) Create a the funding transaction (`Transaction` object).

<details>
  <summary>Step 3 Hint</summary>

To create a transaction, you can use the following helper function:

```rust
pub fn build_transaction(version: Version, locktime: LockTime, tx_ins: Vec<TxIn>, tx_outs: Vec<TxOut>) -> Transaction {
    Transaction {
        version: Version::ONE,
        lock_time: LockTime::ZERO,
        input: tx_ins,
        output: tx_outs,
    }
}
```
When specifying the version and locktime, you can use the following syntax that rust-bitcoin provides. We'll learn about other varieties shortly, but this will help us get started.
- `Version::TWO`: Version 2 is post-BIP-68, which introduced sequence number relative locktimes. 
- `LockTime::ZERO`: This signals that there is no timelock on this transaction.

</details>

## Problem: Potential Loss of Funds

How can Alice lose all of her funds in this setup?

<details>
  <summary>Answer</summary>
  <br/>

  If Bob stops responding or refuses to cooperate, then there's no way for Alice to retrieve her funds from this payment channel. This is because, to spend from a 2-of-2 multisig, you need signatures from *both* parties.
</details>


How can we address this problem for Alice?

<details>
  <summary>Answer</summary>
  <br/>

  There are a few different ways to go about this, but the general solution is that we will need to create a way for Alice to recieve a "refund" or unilateral exit from the channel. Can you think of how we can implement this?
</details>