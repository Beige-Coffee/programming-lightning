# Networking

So far, we've implemented quite a lot of important functionality for our node - sourcing blockchain data, publishing transactions, estimating fees, etc. That's all good fun, but Lightning is a team sport. There is no "I" in team, right? To properly experience the Lightning network, we'll need to communicate with others.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/node_setup/networking.png" alt="networking" width="100%" height="auto">
</p>

## Lightning Network Communication
Broadly speaking, our Lightning node will have to perform the following types of communication with other nodes:
- **Gossip**: The Gossip protocol, described in [BOLT #7: P2P Node and Channel Discovery](https://github.com/lightning/bolts/blob/master/07-routing-gossip.md), defines how Lightning nodes will inform each other of payment channels updates, including opening, closing, and updating channels.
- **Routing**: The Routing protocol, described in [BOLT #4: Onion Routing Protocol](https://github.com/lightning/bolts/blob/master/04-onion-routing.md), defines how Lightning nodes should package payment information such that it can be privately communicated across the network.
- **Channel Management**: The Peer to Peer Channel Management protocol, described in [BOLT #2: Peer Protocol for Channel Management](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md), defines which messages peers should communicate to eachother to open, close, or update a payment channel.

We'll review each of these communication protocols during this workshop. As a sneek peek, you can see a few of the messages within each protocol below.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/node_setup/communication.png" alt="communication" width="100%" height="auto">
</p>

## Channel Management (BOLT# 2)
To participate in Lightning gossip or send payments, you first need an active channel. So it makes sense to start with BOLT #2: Peer Protocol for Channel Management.

#### Question: According to BOLT #7: P2P Node and Channel Discovery, Lightning nodes should ignore `node_announcement` gossip messages from nodes that do not have a known channel. What is the rationale behind this requirement?


<details>
  <summary>Answer</summary>

This rule helps prevent **denial-of-service attacks**. Without it, a malicious actor could flood the network with thousands of `node_announcement` messages, consuming bandwidth and resources. By requiring nodes to have at least one known channel before announcing themselves, the Lightning Network imposes a real-world cost on spamming.

</details>

## Channel Management Phases:

The peer-to-peer channel management protocol has the following three phases: establishment, normal operation, closing.

### Establishment
After two nodes have athenticated and initialized a connection between themselves, they can create a payment channel. There are two options that nodes can use to establish a channel: **Channel Establishment v1** and **Channel Establishment v2**. Channel Establishment v1 is simpler, and it only allows for one party to contribute UTXOs to the channel. When we walked through opening a payment channel in the "Intro to Payment Channels" section, this is the protocol we used (only Alice contributed inputs to the funding transaction).

### Open Channel Message

Since Alice is funding the channel (providing the input UTXO for the funding transcaion), she will begin the process by sending Bob an `open_channel` message.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/operations/open_channel_msg.png" alt="open_channel_msg" width="100%" height="auto">
</p>

In the above picture, you'll notice that some fields have been grayed out. This is because, at this point in the channel establishment process, these fields are not yet known to Alice or Bob. For example, on Alice's side, she does not yet have Bob's funding public key, so she does not yet know the transaction ID.

When Alice sends Bob the `open_channel` message, she is essentially proposing a Lightning channel contract to Bob. The contract will stipulate important requirements information that Alice requires (or desires) to operate a channel with Bob. For example, consider the following fields in the `open_channel` message:
- `max_htlc_value_in_flight_msat`: The maximum value of *outstanding* HTLCs that Bob can offer.
- `max_accepted_htlcs`: The maximum number of *outstanding* HTLCs that Bob can offer.
- `channel_reserve_satoshis`: The minimum value that Bob must keep on his side of the channel. In other words, in outputs that pay directly to him.

Bob will then evaluate Alice's proposed channel and, if acceptable, he will send back a `accept_channel` message.

#### Question: Why would Alice request a channel reserve for Bob?

<details>
  <summary>Answer</summary>

**Funding Transaction**
- Alice needs Bob's funding public key for the funding transaction. Since the Transaction ID is a hash of a subset of the transaction data (not the witness!), we'll also need Bob's funding public key before we can calculate this.

</details>


#### Accept Channel Message

If Bob agrees to Alice's channel proposition, he will send back an `accept_channel` message. His `accept_channel` message will it's own set of requirements that Alice must agree to. For example, one field that Bob proposes is `minimum_depth`, which provides the minimum number of blocks that must be mined on top of the funding transaction before the channel is live. This parameter is provided by the node which is *not* the funder (ex: Bob) because it's meant to protect Bob against Alice double-spending the funding transaction. See below for an example for how such an attack could be carried out:
1) Alice publishes the funding transaction with a low feerate.
2) Bob see the funding transaction in the mempool and, incorrectly, assumes it's safe to start operating the channel
3) Alice sends bob a payment, updating their channel state.
4) Alice secretly creates a new transaction with a high feerate, double-spending the funds in the funding transaction (which is still not yet confirmed)

Ouch!

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/operations/accept_channel_msg.png" alt="accept_channel_msg" width="100%" height="auto">
</p>

#### Question: Sometimes, channel partners may agree to operate a "zero-conf" channel, where they start sending payment to eachother once the funding transaction is in both of their mempools (before it's mined). Why would they do this? What are other risks in addition to the above?

<details>
  <summary>Answer</summary>

Generally, channel partners open a zero-conf channel in circumstances where they wish to start using the channel immediately. For example, imagine you're setting up a Lightning wallet with a reputable Lightning Service Provider (LSP), and you wish to start using your wallet to send payments right away. The LSP may offer zero-conf channels so that their users have a better user experience.

Notice, an important pre-requisite to zero-conf channels is some degree of trust between the two parties. This is because the funding transaction is not solidified in the blockchain until it's been mined. Additionally, due to re-organizations, it's often recommended to wait around 6 blocks before operating a channel.

</details>


#### Funding Created Message
Assuming Alice agrees to the channel propositions proposed in Bob's `accept_channel` message, she will then send Bob a `funding_created` message. In this message, Alice will provide Bob with the information he needs to be able to complete his commitment transaction for the initial channel state - namely the funding transaction TXID, output index, and Alice's signature, which Bob can use in the witness stack if he ever wishes to publish his commitment transaction.

At this point, the only information needed to complete the **Channel Establishment v1** process is a signature from Bob for Alice's commitment transaction. 

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/node_setup/funding_created_msg.png" alt="funding_created_msg" width="100%" height="auto">
</p>

#### Funding Signed Message
Finally, in response to Alice's `funding_created` message, Bob will send Alice a `funding_signed` message. This will contain a `channel_id` and Bob's signature, Which Alice can use for her commitment transaction. Note, since Alice can theoretically have multiple channels with Bob, the `channel_id` field allows Bob to specify which channel he is sending a signature for.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/operations/funding_signed_msg.png" alt="funding_created_msg" width="100%" height="auto">
</p>


#### Channel Ready Message
After recieving Bob's `funding_signed` message, Alice is now able to broadcast the funding transaction safely. This is because, if Bob were to disapear, she can always publish her commitment transaction, which spends the funds from the multi-sig back to herself.

Once Alice broadcasts the funding transaction and its received sufficient confirmations, Alice will send Bob a `channel_ready` message, indicating that the channel is ready for use. Similarly, Bob will send a `channel_ready` message to Alice once he verifies himself that the funding transaction has received sufficient confirmations on-chain.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/operations/channel_ready_msg.png" alt="channel_ready_msg" width="50%" height="auto">
</p>


### Normal Operation
After two nodes have athenticated and initialized a connection between themselves, they can create a payment channel. There are two options that nodes can use to establish a channel: **Channel Establishment v1** and **Channel Establishment v2**. Channel Establishment v1 is simpler, and it only allows for one party to contribute UTXOs to the channel. When we walked through opening a payment channel in the "Intro to Payment Channels" section, this is the protocol we used (only Alice contributed inputs to the funding transaction).

## Connect to Peers
To conenct to peers, we're going to need to implement the ability to conduct high performance I/O operations. For those of you who do not come from a computer networking background, let's take a moment to unpack "high performance I/O operations", as it's helpful to understanding both how Lightning nodes and LDK work under the hood.

First, let's discuss an **Input/Output** (**I/O**) operation. In the context of our Lightning node, an I/O operation refers to the process of exchanging data between our program and external systems (other nodes or servers on the network). This is how we'll be able to communicate vital tasks for our node, such as gathering network gossip, opening channels, and routing payments. 

Now, we don't want our operations (there will be many!) to be slow or get in the way of eachother. In other words, we're going to want "high performance" operations. This means that our operations should have properties like being asynchronous and non-blocking. An asynchronous operation will initiate the task and then immediately continue to executing other tasks. On the other hand, synchronous operations will wait until the current task has finised until moving on to the next one. In other words, it will "block" other tasks from completing while it's waiting.

#### Question: Why is it imperative that our node performs asyncronous I/O instead of synchronous? This may seem like a trivial question, but it's worth pondering if you don't come from a system background!


<details>
  <summary>Answer</summary>

This isn't a trick question! It's just meant to spark further thought.

In short, our Lightning node will be performing many actions at once. For example, we'll be processing new gossip messages, opening channels, routing payments, monitoring the blockchain, etc. The list goes on and on.

If we had to wait for any given task to complete before moving on to another task, we wouldn't be able to run an working node.

</details>

## TCP (Transmission Control Protocol)

To connect to our peers, we'll rely on a TCP/IP connection. This includes protocols such as IPv4, IPv6, and Tor. These protocols are used because they satisfy properties that Lightning requires. For example, consider this sentence from [BOLT #1](https://github.com/lightning/bolts/blob/master/01-messaging.md), which describes Lightning's Base Protocol: **This protocol assumes an underlying authenticated and ordered transport mechanism that takes care of framing individual messages**.

#### Question: Why is ordered transport required by Lightning?


<details>
  <summary>Answer</summary>

First, let's review what "ordered transport" is.

**Ordered transport**, unsurprisingly, means that messages will arrive in the same order that they were sent. To see why this is critical, let's take a brief detour to [BOLT #2: Peer Protocol for Channel Management
](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md). BOLT #2 describes the message types that peers will send eachother to update their channel states. For instance, consider the following common message types:

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/node_setup/alice_bob_tcp_0.png" alt="alice_bob_tcp_0" width="50%" height="auto">
</p>

- `update_add_htlc`: Node A will send this message to node B (or vice versa) to indicate that they would like to add an HTLC to their commitment transactions.
- `commitment_signed`: Node A will send this message to node B (or vice versa) to provide the signature(s) for the current commitment transaction, effectively advancing channel state.

Let's imagine that Alice wants to add two HTLCs to her channel with Bob. She can do that by sending two `update_add_htlc` messages to Bob and then sending a `commitment_signed` message with the appropriate signatures.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/node_setup/alice_bob_tcp_1.png" alt="alice_bob_tcp_1" width="70%" height="auto">
</p>

Notice that the `commitment_signed` does not explitly mention which HTLCs the signatures are for. Instead, it does this implicitly. Since Lightning messages are assumed to be ordered and reliable, the protocol assumes that messages sent will always arrive, and they will arrive in the order they are sent. This way, Alice can rest assured that, if Bob gets the `commitment_signed`, he also got the `update_add_htlc` messages in the correct order.

For a great in-depth blog, discussing how to operate a Lightning channel, please see [Normal operation and closure of a pre-taproot LN channel](https://ellemouton.com/posts/normal-operation-pre-taproot/) by Elle Mouton.

</details>

TCP achieves reliable message delivery by assigning a *sequence number* to each byte of data transmitted to the receiver. To ensure that the data was successfully received, TCP requires the reciever to send a positive acknowledgment (ACK) back to the sender. If the ACK message is not received before the time-out interval, the data will be sent again.

Additionally, since the data is transmitted with sequence numbers, the receiver can correctly order the data they reciever, ensuring that it is processed and handled in the right order. Cool stuff, eh!

## Connecting to Peers

To connect to peers, we'll need to identify them by their **TCP Address**. A TCP address is composed of an **IP Address** and a **Port Number** in the following format: `IP:Port`.

An **IP Address** is used to identify a specific host on a network and functions like a postal address, allowing data to be delivered to the correct location. There are two types of IP Addresses:
- **IPv4**: A 32-bit address
- **IPv6**: A 128-bit address

A **Port Number** identifies the specifi capplication running on the device. It can be a 16-bit integer, effectively between 0-65,535. Lightning's default port is 9735.

Nodes that wish to prioritize privacy and anonymity, may opt to run or leverage a **Tor (The Onion Router)** server, thus concealing their IP Address. The Tor client will then route any incoming or outgoing connections through the Tor network's encrypted relays, thus preserving your privacy. Users who leverage Tor will have an **onion address**, which reads `<username>.onion:<port>`.

## LDK lightning_net_tokio Crate

LDK provides a `lightning_net_tokio` Rust crate which provides a socket handling library for who wish to use rust-lightning with native a `TcpStream`.

LDK has made implementing this create quite easy, with just a few steps to complete.

### Define our TCP Listener

First, we'll need to inform LDK of where our node should be listening for incoming network traffic from. We can do this by defining a `TcpListener` and then passing our listener and a `PeerManager` as inputs to the `setup_inbound` function made available via `lightning_net_tokio`.

```rust
use lightning_net_tokio; // use LDK's sample networking module

let listen_port = 9735;
let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", listen_port))
    .await.unwrap()
loop {
    let tcp_stream = listener.accept().await.unwrap().0;
    tokio::spawn(async move {
        // Use LDK's supplied networking battery to facilitate inbound
        // connections.
        lightning_net_tokio::setup_inbound(
            &peer_manager,
            tcp_stream.into_std().unwrap(),
        )
        .await;
    });
}
```

Let's dig in a little to see what's happening in each step above.

#### 1. Define our TCP Listener
First we create a listener socket, which is bound to the IP address that we provide. 

#### 2. Listen for Connection
Next, we create a loop which will continously check for incoming connections from peers. Specifically, `lister.accept()` will wait asyncronously for an incoming connection. 

#### 3. Spawn a Task to Handle Conneciton
When we have a new conection, we'll spawn an asychronous task to handle the connection. Since each connection is processed with it's own task, we are able to handle multiple connections concurrently.

#### 4. Call `set_inbound` Function
Finally, we'll provide the new connection and a `peer_manager` to the `setup_inbound` function. This will initialize the new connection within the framework of LDK.