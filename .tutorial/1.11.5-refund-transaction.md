# Refund the Channel: Approach 2

So far, we've learned of one construction for building a payment channel, called a "Simple Payment Channel". It works, but it's not ideal, as the channel is time-bound and payments can only, effectively, flow in one direction. Another approach towards building a payment channel is to create an entirely new transaction for the refund channel.

## Approach 2: Create A New "Refund" Transaction That Spends From The Funding Transaction

Another approach would be to create a new transaction that spends from the funding transaction. This transaction will act as a "refund" transaction, as it will pay each channel member the amount of sats that they currently have at the time of opening the channel. Take a minute to see if you can identify how this approach would work.

<details>
  <summary>Answer</summary>
  <br/>

For this approach, we create a second transaction that spends each party's current balance to their public key. This ensures that, if Bob stops responding, Alice can refund her channel balance to herself. Also, there is no arbitrary timeline on this payment channel. Alice can refund the channel balance to herself whenever she likes.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobRefund.png" alt="AliceBobRefund" width="100%" height="auto">
</p>

#### Question: Can the refund transaction be created after broadcasting the funding transaction?
<details>
  <summary>Answer</summary>
  <br/>

It's important to note that this transaction still needs *both* parties to sign the input to this transaction, which is spending the bitcoin from the funding transaction. Therefore, creating the refund transaction should be thought of as a critical step that needs to be completed *before* a channel is live. Otherwise, if Alice or Bob broadcasted the funding transaction before they have both signed the refund transaction, Bob could still go offline and stop Alice from being able to access her bitcoin.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobRefund.png" alt="AliceBobRefund" width="100%" height="auto">
</p>

</details>

</details>


## Locking to Each Channel Party's Public Key
Great! We've identified a way to issue a refund transaction. All we have to do is lock bitcoin to a channel party's **public key**. As we learned earlier, this can be achieved by creating a **Pay-To-Public-Key-Hash** (**P2PKH**) transaction. However, Bitcoin Lightning transactions must use SegWit to avoid *transaction malleability*. Fortunately, we can use a **Pay-To-Witness-Public-Key-Hash** (**P2WPKH**) transaction type to accomplish this!

Similar to **Pay-To-Witness-Script-Hash** (**P2WSH**), the first byte in the **scriptPubKey** for a **P2WPKH** transaction will indicate the **witness version**, which is also ```OP_0```.

Also, note the following:
1) We are introducing a new key, called a **commitment public key**. This key actually has a different name per the protocol specs, but we're not revealing that name yet for educational purposes! 
2) The **commitment public key** has a `1` appended to the end of it. This signals that this public key is specific to this payment (commitment transaction). Each new commitment transaction will have its own *unique* public key.


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceAndBob2.png" alt="SampleTx" width="50%" height="auto">
</p>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobRefundP2WPKH.png" alt="AliceBobRefundP2WPKH" width="100%" height="auto">
</p>

#### Question: Why do we use a new unique public key for each commitment transaction?
<details>
  <summary>Answer</summary>
  <br/>

We change the public key each time so that the transaction ID is not guessable.

</details>

## ⚡️ Build A Payment Channel Funding Transaction

Complete `build_funding_transaction`. This function takes the following parameters:
- `txins`: A vector of transaction inputs (`Vec<TxIn>`).
- `alice_pubkey`: Alice's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `bob_pubkey`: Bob's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `amount`: The channel amount. This will be an `Amount` structure.

You can choose to use `two_of_two_multisig_redeem_script` from our earlier exercise or write the entire script yourself. As long as it's implemented correctly, they should both pass the tests.

```rust
pub fn build_funding_transaction(
    txins: Vec<TxIn>,
    alice_pubkey: &PublicKey,
    bob_pubkey: &PublicKey,
    amount: Amount,
) -> Transaction {

  // build output script

  // build output
  // note, we must call .to_p2wsh() on our witness (redeem) script
  //    to obtain the hash that goes in the output's scriptPubKey field

  // build transaction object
}
```

## ⚡️ Publish Funding Transaction
Now for the fun part! Head over to `src/bin/funding.rs`. Here, you'll see the function `create_broadcast_funding_tx` which is partially implemented but needs to be completed. Below is an overview of what this function does and what you need to complete.

```rust
pub async fn create_broadcast_funding_tx() {
    // get bitcoin client
    let bitcoind = get_bitcoind_client().await;

    // get an unspent output for funding transaction
    let utxo = get_unspent_output(bitcoind.clone()).await;

    // Create a transaction spending this UTXO
    let tx_input = TxIn {
        previous_output: OutPoint {
            txid: // txid,
            vout:// vout,
        },
        sequence: // sequence,
        script_sig: // script_sig,
        witness: // witness,
    };

    // we're locking to a 2-of-2 multisig, so we need two public keys
    // normally, we would generate our own public key
    //   and the counterparty would send us their
    let our_public_key = pubkey_from_private_key(&[0x01; 32]);
    let counterparty_pubkey = pubkey_from_private_key(&[0x02; 32]);

    // build funding transaction using the function we created
    // note:
      // our input needs to be wrapped in a vec -- vec![tx_input]
      // you can specify an amount using -- Amount::from_sat()
    let tx = build_funding_transaction(
          // add parameters
        );

    // we need to serialize the tx before passing it into
    //    `sign_raw_transaction_with_wallet`
    let tx_hex = serialize_hex(&tx);

    // sign the transaction
      //
    let signed_tx = bitcoind.sign_raw_transaction_with_wallet(tx_hex).await;

    // convert signed transaction hex into a Transaction type
    let final_tx: Transaction =
        encode::deserialize(&hex_utils::to_vec(&signed_tx.hex).unwrap()).unwrap();

    println!("Tx Hex: {}", serialize_hex(&final_tx));
    println!("Tx ID: {}", final_tx.compute_txid());

    // broadcast transaction
    bitcoind.broadcast_transactions(&[&final_tx]);
}
```

If you'd like to see a more detailed description for how to complete this function, click below!
<details>
<summary>More Details</summary>
  
#### Step 1: Get Bitcoind client and find an unspent UTXO
The first part of the function is implemented for us. If you'd like to see what's going on under the hood, you can check `src/bin/funding_solution.rs`, though don't peak around too much because the rest of the solution is also in this file!

This part of the code will simply connect to the Regtest environment running in this Replit and find an unspent UTXO that we can use for our funding channel.
```rust
// get bitcoin client
let bitcoind = get_bitcoind_client().await;

// get an unspent output for funding transaction
let utxo = get_unspent_output(bitcoind.clone()).await;
```

#### Step 2: Create transaction input (`TxIn`)
For this part of the exercise, you'll have to define the input to our funding transaction.

Recall that a  `TxIn` has the following fields:

```rust
pub struct TxIn {
    pub previous_output: OutPoint,
    pub script_sig: ScriptBuf,
    pub sequence: Sequence,
    pub witness: Witness,
}
```

`Output` has the following fields:

```rust
pub struct OutPoint {
    pub txid: Txid,
    pub vout: u32,
}
```

You can access the `txid` and `vout` of an output by calling `.txid` and `.vout` on the utxo we're specifying.

Also, for now, we're going to add empty `script_sig` and `witness`, and we'll put the max value for `sequence`, indicating that we are not implementing a timelock on this input. You can do that by calling the following methods:
- `Sequence::MAX`
- `ScriptBuf::new()`
- `Witness::new()`

#### Step 3: Call `build_funding_transaction`
We can now call `build_funding_transaction`, the function we just created, and pass in the required inputs.

#### Step 4: Sign and broadcast transaction
Now that we have our `Transaction` struct ready, we can sign and broadcast the transaction. To do this, we need to leverage the following methods on our bitcoin client.

- `bitcoind.sign_raw_transaction_with_wallet(tx_hex).await`
- `bitcoind.broadcast_transactions(&[&final_tx]);`

</details>

## ⚡️ Verify transaction
Once you complete the function, you can run it by pasting `cargo run --bin funding` in the Shell. If it's implemented correctly, it should return something like the following:

```
Tx Hex: 0200000000010115ace9b822d10a14627a3ae0eea989f9556cd4ed86b53ab09f86f6cdedb31ec20100000000ffffffff01784a4c0000000000220020657760ca015175e42ff5b4470563b23adcf0d2973a0506a176a5569690d64437024730440220550b7b814ef898403bb70691dc6f3421be69c2edd91fb1e05a7dc0af6f0a495b0220680205d7e0249b4d381791fef5d27d701c514e8bcb7e593fc889ff5cf784497d01210238ad1ae27ea475eb612c2d9a37152400156488ed4ba0bd11eda03bf1f98d915100000000
Tx ID: 8d58f5fe0f6e796b8376fee61b2ce5cac7c92f5aa0effc92a8abfb9c8f1d3078
```

You can then leverage the following commands in your shell to confirm that the transaction has broadcasted correctly and see the contents of the transaction.

```
bcli gettransaction <txid>
```

```
bcli decoderawtransaction <raw_tx_hex>
```
