# Refund the Channel: Approach 2

So far, we've learned of one construction for building a payment channel, called a "Simple Payment Channel". It works, but it's not ideal, as the channel is time-bound and payments can only, effectively, flow in one direction. Another approach towards building a payment channel is to create an entirely new transaction for the refund channel.

## Approach 2: Create A New "Refund" Transaction That Spends From The Funding Transaction

Another approach would be to create a new transaction that spends from the funding transaction. This transaction will act as a "refund" transaction, as it will pay each channel member the amount of sats that they currently have at the time of opening the channel. Take a minute to see if you can identify how this approach would work.

<details>
  <summary>Answer</summary>
  <br/>

For this approach, we create a second transaction that spends each party's current balance to their public key. This ensures that, if Bob stops responding, Alice can refund her channel balance to herself. Also, there is no arbitrary timeline on this payment channel. Alice can refund the channel balance to herself whenever she likes.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobRefund.png" alt="AliceBobRefund" width="100%" height="auto">
</p>

#### Question: Can the refund transaction be created after broadcasting the funding transaction?
<details>
  <summary>Answer</summary>
  <br/>

It's important to note that this transaction still needs *both* parties to sign the input to this transaction, which is spending the bitcoin from the funding transaction. Therefore, creating the refund transaction should be thought of as a critical step that needs to be completed *before* a channel is live. Otherwise, if Alice or Bob broadcasted the funding transaction before they have both signed the refund transaction, Bob could still go offline and stop Alice from being able to access her bitcoin.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobRefund.png" alt="AliceBobRefund" width="100%" height="auto">
</p>

</details>

</details>


## Locking to Each Channel Party's Public Key
Great! We've identified a way to issue a refund transaction. All we have to do is lock bitcoin to a channel party's **public key**. As we learned earlier, this can be achieved by creating a **Pay-To-Public-Key-Hash** (**P2PKH**) transaction. However, Bitcoin Lightning transactions must use SegWit to avoid *transaction malleability*. Fortunately, we can use a **Pay-To-Witness-Public-Key-Hash** (**P2WPKH**) transaction type to accomplish this!

Similar to **Pay-To-Witness-Script-Hash** (**P2WSH**), the first byte in the **scriptPubKey** for a **P2WPKH** transaction will indicate the **witness version**, which is also ```OP_0```.

Also, note the following:
1) We are introducing a new key, called a **commitment public key**. This key actually has a different name per the protocol specs, but we're not revealing that name yet for educational purposes! 
2) The **commitment public key** has a `1` appended to the end of it. This signals that this public key is specific to this payment (commitment transaction). Each new commitment transaction will have its own *unique* public key.


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceAndBob2.png" alt="SampleTx" width="50%" height="auto">
</p>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobRefundP2WPKH.png" alt="AliceBobRefundP2WPKH" width="100%" height="auto">
</p>

#### Question: Why do we use a new unique public key for each commitment transaction?
<details>
  <summary>Answer</summary>
  <br/>

We change the public key each time so that the transaction ID is not guessable.

</details>

## ⚡️ Build A Payment Channel Refund Transaction

Complete `build_refund_transaction`. This function takes the following parameters:
- `funding_txin`: Funding transaction input (`TxIn`).
- `alice_pubkey`: Alice's public key (`&PublicKey`), which will used to build Alice's output.
- `bob_pubkey`: Bob's public key (`&PublicKey`), which will be used to build Bob's output.

You can choose to use the following functions from our earlier excercises to help complete the function:
- `build_output`
- `build_transaction`

Also, you can obtain a **P2WPKH** output script by using the below function:

```rust
let p2wpkh_output_script = p2wpkh_output_script(pubkey);
```


```rust
pub fn build_refund_transaction(
    funding_txin: TxIn,
    alice_pubkey: Secp256k1PublicKey,
    bob_pubkey: Secp256k1PublicKey,
    alice_balance: u64,
    bob_balance: u64
) -> Transaction {

    // create alice and bob's output scripts

    // define alice and bob's unique outputs
    //    note, we must call .to_p2wsh() on our P2WSH scripts
    //    to obtain the hash that goes in the output's scriptPubKey field
  
    // declare the version and locktime for the transaction

    // build transaction
    // -- remember, inputs and outputs must be passed in as vectors (vec![])
}
```