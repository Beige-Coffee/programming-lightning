# LDK Keys

As we saw earlier, there a quite a bit of keys that are utilized *just* for payment channel operations. In addition to this, a lightning network node also stores keys related to: 

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/keys/key_purposes.png" alt="key_purposes" width="60%" height="auto">
</p>

So, how does LDK manage all of these keys in a safe and secure way? Before getting into the details, let's review BIP 32.

#### Why not use the same key for everything?

# BIP 32

Bitcoin Improvement Proposal (BIP) 32 describes a **hierarchical deterministic** (HD) wallet structure that introduces the following characteristics to key management:
- **Single Source**: All public and private keys can be derived from a single seed phrase. As long as this single seed phrase is safely secured, you can re-derive the entire wallet.
- **Hierarchical**: All keys and addresses can be organized in a tree structure.
- **Deterministic**: All keys and addresses are generated the same exact way. Each time you restore you wallet from your seed, you'll get the exact same result.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/keys/HDWallets.png" alt="HDWallets" width="70%" height="auto">
</p>

This hierarchical strucuture can be quite useful. For example, in the below diagram, we've created new ***normal*** child private keys for the following tasks:
- **Gossip Protocol**: Sign gossip announcements, decode onion data, etc.
- **On-Chain**: Derive private and public keys which can be used to generate outputs that spend from payment channels that are closing such that we now unilaterally control those outputs.
- **Payment Channel**: Derive all of the public and private keys we need to operate a payment channel (ex: revocation key, htlc key, delayed key, etc.). Furthermore, each channel will have its own child key from this derivation path.
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/keys/ldk_key_ex.png" alt="ldk_key_ex" width="70%" height="auto">
</p>

#### Question: Is there a problem with the above derivation construction? Specifically, should any of these child private keys use "hardened" keys?
<details>
  <summary>
    Answer
</summary>

Yes, there is a big problem! Every ***normal*** child private key has an associated *extended public key* which can create a series of public keys for this private key. These public keys can be generated independently of the child private keys, which makes it safe to expose this to the public. 
  
However, if any child private key were to be accidentally leaked ***and*** the extended public key were known, then a bad actor could calculate the parent private key and, therefore, derive all child private keys at this level. This would mean that all of our channels would be at risk of being drained.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/keys/ldk-key-expose.png" alt="ldk-key-expose" width="50%" height="auto">
</p>

If, instead, we generate ***hardened*** child private keys, then there will be no associated extended public key. Therefore, if we leak one of our child private keys, only the funds on that specific channel are at risk. The rest of our channels are safe. To protect our LDK node and ensure that any private key leaks are isolated, LDK will derive hardened private keys in most situations.
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/keys/ldk_key_hardened.png" alt="ldk_key_hardened" width="60%" height="auto">
</p>

</details>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/keys/ldk_keys.png" alt="ldk_keys" width="100%" height="auto">
</p>

#### Question: Imagine you're running a lightning node. What information needs to be backed up so that you re-derive all  keys and continue operations if your node goes offline?

<details>
  <summary>
    Answer
</summary>
- Seed
- Channel Parameters
</details>

## ⚡️ Write Function `new_simple_key_manager` To Generate A Key Manager

```rust
pub fn new_simple_key_manager(seed: [u8; 32]) -> SimpleKeysManager{
}
```

LDK provides a ```KeysManager``` structure to assist in key management and signing operations. We'll discuss this in more detail shortly, but, for this exercise, we'll impliment a simpler version, called the ```SimpleKeysManager```.

The ```SimpleKeysManager``` has the following structure:
```rust
struct SimpleKeysManager {
    pub node_secret: SecretKey,
    pub node_id: Secp256k1PublicKey,
    pub shutdown_pubkey: Secp256k1PublicKey,
    pub channel_master_key: Xpriv,
    pub channel_child_index: u32,
    pub seed: [u8; 32],
}
```

The `new_simple_key_manager` function will take a 32-byte ```seed``` as an input and return a ```SimpleKeysManager``` strucure that meets the above requirement types for each component.

To help you with completing this excercise, the following functions are available to you:

```rust
fn get_master_key(seed: [u8; 32]) -> Xpriv {
  // create master key from seed
}
```

```rust
fn get_hardened_child_private_key(master_key: Xpriv, idx: u32) -> SecretKey {
  // create hardened child private key from given master key and index
}
```

```rust
fn get_hardened_extended_child_private_key(master_key: Xpriv, idx: u32) -> Xpriv {
  // create hardened extended child private key from given master key and index
}
```

```rust
fn get_public_key(private_key: SecretKey) -> Secp256k1PublicKey {
  // create public key from private key
}
```

If you would like a hint, click below:
<details>
  <summary>Hint</summary>
  <br/>

Try implementing the following:

```rust
pub fn new_simple_key_manager(seed: [u8; 32]) -> SimpleKeysManager{

    // create master key

    // derive node secret

    // derive node id

    // derive shutdown private key

    // derive shutdown public key

    // derive channel extended private key

    // populate and return SimpleKeysManager
    SimpleKeysManager {
        node_secret: //,
        node_id: //,
        shutdown_pubkey: //,
        channel_master_key: //,
        channel_child_index: //,
        seed: //,
    }
  ```
  
</details>