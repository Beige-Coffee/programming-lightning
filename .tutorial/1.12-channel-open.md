# Channel Open

Now that Alice and Bob have created their funding transaction and, crucially, refund transaction, they are ready to open their channel. Remember, Alice cannot broadcast the funding transaction without having a refund transaction ready, as this would open Alice up to the risk that Bob stops responding or refuses to cooporate, effectively locking Alice's funds in this channel forever! 

Once these transactions are created, the next step is to broadcast the funding transaction to the Bitcoin network and wait for it to be included in a block. To ensure the transaction is considered final and irreversible, it’s standard practice to wait until the block containing the transaction has at least 6 confirmations (i.e., 6 additional blocks mined on top of it).

As part of our payment channel protocol, we will need to be able to monitor the chain and watch for a block that contains this funding transaction output before we can consider the payment channel safe to operate.

## ⚡️ Publish Funding Transaction
Now for the fun part! Head over to `src/bin/funding.rs`. Here, you'll see the function `create_broadcast_funding_tx` which uses the function we created in the previous exercise to create a funding transaction for our payment channel.

```rust
pub async fn create_broadcast_funding_tx(bitcoind: BitcoindClient,
                                        tx_input: TxIn,
                                        tx_in_amount: u64) {

    // we're locking to a 2-of-2 multisig, so we need two public keys
    // normally, we would generate our own public key
    //   and the counterparty would send us theirs
    let our_public_key = secp256k1_pubkey_from_private_key(&[0x01; 32]);
    let counterparty_pubkey = secp256k1_pubkey_from_private_key(&[0x02; 32]);

    // build funding transaction using the function we created
    let tx = build_funding_transaction(
            vec![tx_input],
            &our_public_key,
            &counterparty_pubkey,
            tx_in_amount,
        );

    let signed_tx = sign_raw_transaction(bitcoind.clone(), tx).await;


    println!("Tx Hex: {}", serialize_hex(&signed_tx));
    println!("Tx ID: {}", signed_tx.compute_txid());

    // broadcast transaction
    bitcoind.broadcast_transactions(&[&signed_tx]);
}
```

If you'd like to see a more detailed description for how to complete this function, click below!
<details>
<summary>More Details</summary>

#### Step 1: Get Bitcoind client and find an unspent UTXO
The first part of the function is implemented for us. If you'd like to see what's going on under the hood, you can check `src/bin/funding_solution.rs`, though don't peak around too much because the rest of the solution is also in this file!

This part of the code will simply connect to the Regtest environment running in this Replit and find an unspent UTXO that we can use for our funding channel.
```rust
// get bitcoin client
let bitcoind = get_bitcoind_client().await;

// get an unspent output for funding transaction
let utxo = get_unspent_output(bitcoind.clone()).await;
```

#### Step 2: Create transaction input (`TxIn`)
For this part of the exercise, you'll have to define the input to our funding transaction.

Recall that a  `TxIn` has the following fields:

```rust
pub struct TxIn {
    pub previous_output: OutPoint,
    pub script_sig: ScriptBuf,
    pub sequence: Sequence,
    pub witness: Witness,
}
```

`Output` has the following fields:

```rust
pub struct OutPoint {
    pub txid: Txid,
    pub vout: u32,
}
```

You can access the `txid` and `vout` of an output by calling `.txid` and `.vout` on the utxo we're specifying.

Also, for now, we're going to add empty `script_sig` and `witness`, and we'll put the max value for `sequence`, indicating that we are not implementing a timelock on this input. You can do that by calling the following methods:
- `Sequence::MAX`
- `ScriptBuf::new()`
- `Witness::new()`

#### Step 3: Call `build_funding_transaction`
We can now call `build_funding_transaction`, the function we just created, and pass in the required inputs.

#### Step 4: Sign and broadcast transaction
Now that we have our `Transaction` struct ready, we can sign and broadcast the transaction. To do this, we need to leverage the following methods on our bitcoin client.

- `bitcoind.sign_raw_transaction_with_wallet(tx_hex).await`
- `bitcoind.broadcast_transactions(&[&final_tx]);`

</details>

## ⚡️ Verify transaction
Once you complete the function, you can run it by pasting `cargo run --bin funding` in the Shell. If it's implemented correctly, it should return something like the following:

```
Tx Hex: 0200000000010115ace9b822d10a14627a3ae0eea989f9556cd4ed86b53ab09f86f6cdedb31ec20100000000ffffffff01784a4c0000000000220020657760ca015175e42ff5b4470563b23adcf0d2973a0506a176a5569690d64437024730440220550b7b814ef898403bb70691dc6f3421be69c2edd91fb1e05a7dc0af6f0a495b0220680205d7e0249b4d381791fef5d27d701c514e8bcb7e593fc889ff5cf784497d01210238ad1ae27ea475eb612c2d9a37152400156488ed4ba0bd11eda03bf1f98d915100000000
Tx ID: 8d58f5fe0f6e796b8376fee61b2ce5cac7c92f5aa0effc92a8abfb9c8f1d3078
```

You can then leverage the following commands in your shell to confirm that the transaction has broadcasted correctly and see the contents of the transaction.

```
bcli gettransaction <txid>
```

```
bcli decoderawtransaction <raw_tx_hex>
```


## ⚡️ Write a function `block_connected` that is called when new blocks are found and returns whether or not a valid funding output was found in this block

We want to make sure the funding output script is included in the block *and* that the channel amount is correct.

<br/>

A `Block` has the following structure:

```rust
pub struct Block {
    pub header: BlockHeader,
    pub txdata: Vec<Transaction>,
}
```

<br/>

A `Transaction` has the following structure:

```rust
pub struct Transaction {
    pub version: i32,
    pub lock_time: PackedLockTime,
    pub input: Vec<TxIn>,
    pub output: Vec<TxOut>,
}
```

<br/>

A `TxOut` has the following structure:

```rust
pub struct TxOut {
    pub value: u64,
    pub script_pubkey: Script,
}
```

<br/>

A `Vec` in rust is an array type and can be iterated using `for` item `in` array loop like this:

```rust
let arr = vec![1,2,3,4,5];

for num in arr {
  println!("{num}"); 
}
```

<br/>

We want to iterate over the blocks transactions and for each transaction iterate over all of it's outputs.  We are looking for an output that has the a `script_pubkey` equal to the `funding_output` script and an `amount` equal to the `channel_amount_sats`.

```rust
fn block_connected(funding_output: Script, channel_amount_sats: u64, block: Block) -> bool {}
```

<details>
  <summary>Click here if you need a hint</summary>
  <br/>

Psuedo code is provided below.
```rust
fn block_connected(funding_output: ScriptBuf, channel_amount_sats: u64, block: Block) -> bool {
    // for each transaction in block

        // for each output in transaction outputs

            // if output script_pubkey = funding_output AND output value = channel_amount_sats
                    
                // return true
            
    // return false
}
```

</details>