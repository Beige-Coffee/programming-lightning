# Pay-to-Script-Hash (P2SH)

Okay, we've reviewed a **Pay-to-Public-Key-Hash** script. This was relatively simlple and easy to understand. Do we really need to make things more complicated? Of course we do! While P2PKH is sufficient to send bitcoin to someone else, it doesn't allow us to create more complex spending conditions, which are ultimately needed to build additional functionality on Bitcoin. Let's discuss the slightly more complicated, yet flexible, script: **Pay-to-Script-Hash** (**P2SH**).

In a P2SH transaction, bitcoin is "locked" to the hash of a script, as opposed to the hash of public key. The script specifies the conditions that must be met to spend the bitcoin later on. To unlock the bitcoin, the spender must provide:
- The original (unhashed) **Redeem Script** that, when hashed, matches the hash that the bitcoin is locked to.
- Any other data that the redeem script specfies, such as a valid **signature**, **preimage**, etc.)
###
#### What benefits do we obtain by locking to the hash of a script?
<details>
  <summary>Answer</summary>

By locking the bitcoin to the hash of a script, we obtain a few benefits:

1) **Flexibility**: While P2PKH is limited to locking Bitcoin to a single public key, P2SH allows for the bitcoin to be locked to more complex conditions, such as requiring multiple signatures to spend the funds (also known as "Multisig"). As we'll see when we dig into the Lightning Network, a variation of P2SH can be used to lock bitcoin to the hash of a secret message, called a "preimage". Therefore, to spend the funds, you must prove that you know the original secret that produced the hash.
2) **Security**: As we discussed earlier, Bitcoin transactions are publicly viewable on the blockchain. By locking the Bitcoin to a hash of a script, the spending conditions of the script are not viewable until the funds are spent later on.

</details>

## Locking To Multisig
To build our intuition of a P2SH script, let's walk through an example where we'd like to lock our funds such that multiple keys are required to spend those funds. This is a very popular use of P2SH transactions.

For this example, we'll lock our bitcoin such that 2 of 2 signatures must be presented to spend the funds. This is a very popular construct for bitcoin custody today.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/p2sh-2-2-multisig.png" alt="p2sh-2-2-multisig" width="70%" height="auto">
</p>

```
 2 <pubkey1> <pubkey2> 2 OP_CHECKMULTISIG 
```
Let's build a function that takes in two Bitcoin public keys and returns a Script. In this case, this script will be our **Redeem Script**, and it will only be presented when we unlock these bitcoin in the future. However, since we are locking these bitcoin to the hash of this script, we need to create it now.

### ⚡️ Generate Multisig Pay-To-Script-Hash Transaction

### Exercise #1: Build 2-of-2 Multisig Redeem Script

Can you write the implementation for a function that takes in two Bitcoin PublicKeys and generates a 2-of-2 multisig redeem script? 
```rust
fn two_of_two_multisig_redeem_script(pubkey1: &PublicKey, pubkey2: &PublicKey) -> Script {}
```


### Exercise #2: Build Output

Now that we've created our redeem script, let's create a function that will return an output object that we can use when creating outputs for future transactions. To help with this, rust bitcoin provides a `TxOut`  structure for representing a transaction output. You can read more about this struct [here](https://docs.rs/bitcoin/latest/bitcoin/struct.TxOut.html).

```rust
pub struct TxOut {
    pub value: Amount,
    pub script_pubkey: ScriptBuf,
}
```

Complete ```build_output``` function. This function will take an ```Amount``` and ```output_script``` as an input and produce a TxOut structure that can be used in a rust bitcoin ```Transaction```.

```rust
fn build_output(amount: u64, output_script: ScriptBuf) -> TxOut {
}
```
**NOTE**: Our function will take an unsigned 64-bit integer (`u64`) as an input, but `value` needs to be an `Amount` structure, as defined by **rust bitcoin**. You can convert a `u64` number to an `Amount` by leveraging the `Amount::from_sat(<amount>)` syntax.**

### Exercise #3: Create Multisig Transaction

Complete the ```build_v1_multisig_transaction``` function. This function will take two public keys, `pubkey1` and `pubkey2` as inputs, as well as a vector of tx inputs, `tx_ins`, and an amount for this output. It will return a `Transaction` type. You can use the two functions from the previous exercises to build the multisig script and output for this transaction. 

```rust
pub fn build_v1_multisig_transaction(
    tx_ins: Vec<TxIn>,
    pubkey1: &Secp256k1PublicKey,
    pubkey2: &Secp256k1PublicKey,
    amount: u64,
) -> Transaction
```

Rust-bitcoin defines a``Transaction`` structure for representing a Bitcoin transaction. Each field within this struct requires that it be of a specific type. For example, the ```version``` must be a ```Version``` type. You can read more about this struct [here](https://docs.rs/bitcoin/latest/bitcoin/struct.Transaction.html).
```rust
pub struct Transaction {
    pub version: Version,
    pub lock_time: LockTime,
    pub input: Vec<TxIn>,
    pub output: Vec<TxOut>,
}
```

To create a transaction, you can use the following helper function:

```rust
pub fn build_transaction(version: Version, locktime: LockTime, tx_ins: Vec<TxIn>, tx_outs: Vec<TxOut>) -> Transaction {
    Transaction {
        version: Version::ONE,
        lock_time: LockTime::ZERO,
        input: tx_ins,
        output: tx_outs,
    }
}
```
When specifying the version and locktime, you can use the following syntax that rust-bitcoin provides. We'll learn about other varieties shortly, but this will help us get started.
- `Version::ONE`: This is a version 1 transaction. Version 1 is pre-BIP-68, which introduced sequence number relative locktimes. 
- `LockTime::ZERO`: This signals that there is no timelock on this transaction.

