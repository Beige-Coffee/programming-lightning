# Simple Payment Channel

You can conceptually think of a payment channel as a way to perform batching of your payments over a potentially unlimited length of time. In fact, with a simple payment channel, two parties can make thousands of payments between each other while only ever making two on-chain bitcoin transactions. This reduces the costs, on-chain data footprint, and speed of sending transactions, alleviating the three problems we identified earlier. 

## Core concept

So how is this possible? What is going on when payments are made in a payment channel?

The idea is that the two parties will still construct bitcoin transactions for each payment being made ***but they agree not to broadcast them to the chain***. By not broadcasting each transaction to the chain, the parties do not need to:
1) Wait for confirmations.
2) Pay miner fees
3) Force resource costs onto the entire network.

Crucially, these transaction payments are considered "valid", because they contain all the appropriate signatures and conditions to be included in a block. However, channel partners ***choose*** not to broadcast them until they decide to (or need to) close the channel.

For example, imagine Alice and Bob are all grown and now drink adult beverages. In fact, Bob started his own bar (good luck!). Since they both love Bitcoin, Alice decides to pay Bob in Bitcoin whenever she goes to his bar, but, to save on transaction fees, Alice and Bob agree to create a "payment channel", such that they only need to:
1) Create a transaction that locks funds into an output they both control.
2) Exchange **unbroadcasted** transactions, which represent payments.
3) Publish their final balances back to the chain to outputs they unilaterally control.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobBar.png" alt="AliceBobBar" width="100%" height="auto">
</p>

## Creating a Simple Payment Channel

To bring this payment channel to life, let's equip Alice and Bob with private and public keys. As we work through this workshop, we'll represent their **signatures** with a **signature** logo, and we'll represent their locking to their **public keys** with a **lock** logo.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AliceBobKeys.png" alt="AliceBobKeys" width="60%" height="auto">
</p>

To create a payment channel, Alice and Bob start by agreeing to fund a 2-of-2 multisig output with a specific amount. This amount is crucial, as it represents the total channel capacity, meaning Alice and Bob will only be able to transfer up to this amount between themselves.

To fund this channel, Alice and Bob create a **Pay-to-Witness-Script-Hash (P2WSH)** transaction that locks their channel balance into an output controlled by both of them. Specifically, this output requires both Alice and Bob to control one of the keys necessary to spend the funds. 


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/funding.png" alt="funding.png" width="100%" height="auto">
</p>

### Sending a Payment
Then, to send a payment Alice and Bob can simply create a new transaction that spends from the funding transaction. Each new transaction will have an output for Alice and Bob with their respective channel balances.

**Crucially, Alice will sign the transaction and send it to Bob, but Bob will not sign it yet**. This way, Alice cannot broadcast an old transaction, but Bob can decide to sign and close the channel when ready.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/simple_payment.png" alt="simple_payment" width="100%" height="auto">
</p>

## ‚ö°Ô∏è Build A Payment Channel Funding Transaction

Complete `build_funding_transaction`. This function takes the following parameters:
- `txins`: A vector of transaction inputs (`Vec<TxIn>`).
- `alice_pubkey`: Alice's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `bob_pubkey`: Bob's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `amount`: The channel amount. This will be an unsigned 64-bit integer `u64` structure.

```rust
pub fn build_funding_transaction(
    txins: Vec<TxIn>,
    alice_pubkey: &PublicKey,
    bob_pubkey: &PublicKey,
    amount: Amount,
) -> Transaction {

  // build output script

  // build tx output
  //    note, we must call .to_p2wsh() on our witness (redeem) script
  //    to obtain the hash that goes in the output's scriptPubKey field

  // define version and locktime for transaction 

  // build transaction object
}
```

This transaction will return a `Transaction` structure, as defined by Rust Bitcoin.

```rust
pub struct Transaction {
    pub version: Version,
    pub lock_time: LockTime,
    pub input: Vec<TxIn>,
    pub output: Vec<TxOut>,
}
```

### To complete this exercise, we'll need to implement the following steps:

#### 1) Build a redeem script for our multisig.
<details>
  <summary>Step 1 Hint</summary>

Use the `two_of_two_multisig_witness_script` function you created in an earlier exercise.

</details>

#### 2) Create an output (`TxOut` object) to be included in our funding transaction

<details>
  <summary>Step 2 Hint</summary>

A `build_output` function is available to you that takes an `amount` and `output_script` as an argument and produces a `TxOut` object that can be passed into a transaction.

**Note**: You will want to call `.to_p2wsh()` on your redeem script from step one either as you pass it in to `build_output` or before. This is because `.to_p2wsh()` will convert your redeem script into an output script! In other works, in the format `OP_0 <32 byte hash>`.

```rust
pub fn build_output(amount: u64, output_script: ScriptBuf) -> TxOut {
    
    TxOut {
        value: Amount::from_sat(amount),
        script_pubkey: output_script,
    }
}
```

</details>

#### 3) Create a the funding transaction (`Transaction` object).

<details>
  <summary>Step 3 Hint</summary>

To create a transaction, you can use the following helper function:

```rust
pub fn build_transaction(version: Version, locktime: LockTime, tx_ins: Vec<TxIn>, tx_outs: Vec<TxOut>) -> Transaction {
    Transaction {
        version: Version::ONE,
        lock_time: LockTime::ZERO,
        input: tx_ins,
        output: tx_outs,
    }
}
```
When specifying the version and locktime, you can use the following syntax that rust-bitcoin provides. We'll learn about other varieties shortly, but this will help us get started.
- `Version::TWO`: Version 2 is post-BIP-68, which introduced sequence number relative locktimes. 
- `LockTime::ZERO`: This signals that there is no timelock on this transaction.

```rust
let version = Version::TWO;
let locktime = LockTime::ZERO;
```

</details>

## üëâ Get Our Funding Transaction
Now for the fun part! Once your `build_funding_transaction` is passing the tests, go to a **Shell** in your Repl and type in the below command.

```
cargo run --bin funding
```
This command is calling a function within `src/bin/funding.rs` which fetches a UTXO from our regtest wallet and sends it to a two-of-two multisig. Once you run it, you should see an output like this...

```
Tx ID:
8077cb7913e97caefb6199deeb1a14b4ecc740206f05cdfb56605da794ae0e8f

Tx Hex: 020000000001018d54238793c4547bb913e369a27c74bc08fc20c33197f5690f41565c7cfad12e0000000000ffffffff01784a4c0000000000220020657760ca015175e42ff5b4470563b23adcf0d2973a0506a176a5569690d64437024730440220548d3aeae38390d1d4f79b8756b5758d131051ddce223aa4f395bb88be1ccaeb02201698654ab9c29d41822771cd3a75bffec87488322a46783f64cd53aefb1f5d960121024e77786b0c8bef20ef469345cf4c306b14dee25dd5bab152155bee1e2115e93100000000
```

This is our funding transaction. **Note: we have NOT broadcasted this yet**. Go ahead and copy the **Tx Hex** and **Tx ID** and save them in the file `src/ch1_intro_htlcs/transactions.txt` under the headings **Funding Tx Hex** and **Funding Tx ID**. This is our funding transaction, but we need to wait to publish it!

## Problem: Potential Loss of Funds

How can Alice lose all of her funds in this setup?

<details>
  <summary>Answer</summary>

  If Bob stops responding or refuses to cooperate, then there's no way for Alice to retrieve her funds from this payment channel. This is because, to spend from a 2-of-2 multisig, you need signatures from *both* parties.
</details>


How can we address this problem for Alice?

<details>
  <summary>Answer</summary>

  There are a few different ways to go about this, but the general solution is that we will need to create a way for Alice to recieve a "refund" or unilateral exit from the channel. Can you think of how we can implement this?
</details>