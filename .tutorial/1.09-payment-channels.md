# Locking Funds In Our Payment Channel

As we just learned, for a payment channel to operate in a trustless environment, we're going to need to ensure that the funds being transfered **off-chain** in the payment channel cannot be unilaterally moved **on-chain** in such a way that effectively steals from your channel party. In other words, Alice should not be able to show up to Bob's bar, give him an off-chain transaction in exchange for a glass of wine, and then move the same UTXO referenced in the off-chain transaction such that Bob's transansaction is no longer valid.

To mitigate against this vulnerability, we can begin our payment channel by locking the channel funds in a **Pay-to-Witness-Script-Hash (P2WSH) 2-of-2 multisig output** where Alice and Bob both provide one public key. We'll call this transaction our **"Funding Transaction"**. To move the funds out of this UTXO (effectively, closing the channel), Alice and Bob will need to both provide their signatures.

To keep things simple, Alice will initially provide the funds for this payment channel, so she will be providing the input to this **"Funding Transaction"**. You can think of this as Alice showing up to Bob's bar and opening a tab with a pre-allocated amount.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/funding.png" alt="funding.png" width="100%" height="auto">
</p>

#### Question: You'll see in the above diagram that Funding Transaction UTXO is for 5,000,000 sats. Why is this amount so important for our payment channel?
<details>
  <summary>Answer</summary>

The amount in this UTXO is going to be channel balance for this payment channel. Therefore, neither channel party will be able to send the other channel party **more than this amount** of sats, and that is still only in unique circumstances.

There are ways to increase this amount while the channel is active, but that is more advanced and will be covered later in this course.

</details>

### Sending a Payment
Then, to send a payment Alice and Bob can simply create a new transaction that spends from the funding transaction. Each new transaction will have an output for Alice and Bob with their respective channel balances.

**Crucially, Alice will sign the transaction and send it to Bob, but Bob will not sign it yet**. This way, Alice cannot broadcast an old transaction, but Bob can decide to sign and close the channel when ready.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/simple_payment.png" alt="simple_payment" width="100%" height="auto">
</p>

## ‚ö°Ô∏è Build A Payment Channel Funding Transaction

Complete `build_funding_transaction`. This function takes the following parameters:
- `txins`: A vector of transaction inputs (`Vec<TxIn>`).
- `alice_pubkey`: Alice's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `bob_pubkey`: Bob's public key (`&PublicKey`), which will be included in the 2-of-2 multisig.
- `amount`: The channel amount. This will be an unsigned 64-bit integer `u64` structure.

```rust
pub fn build_funding_transaction(
    txins: Vec<TxIn>,
    alice_pubkey: &PublicKey,
    bob_pubkey: &PublicKey,
    amount: Amount,
) -> Transaction {

  // build output script

  // build tx output
  //    note, we must call .to_p2wsh() on our witness (redeem) script
  //    to obtain the hash that goes in the output's scriptPubKey field

  // define version and locktime for transaction 

  // build transaction object
}
```

This transaction will return a `Transaction` structure, as defined by Rust Bitcoin.

```rust
pub struct Transaction {
    pub version: Version,
    pub lock_time: LockTime,
    pub input: Vec<TxIn>,
    pub output: Vec<TxOut>,
}
```

### To complete this exercise, we'll need to implement the following steps:

#### 1) Build a redeem script for our multisig.
<details>
  <summary>Step 1 - More Info</summary>

Use the `two_of_two_multisig_witness_script` function you created in an earlier exercise.

**Note**, to declare a variable in rust, you use the `let` keyword. ALso, each statement in Rust, including variable declarations, must end with a semicolon (`;`). For example, to create a variable that holds an integer, we could write:

```rust
let number = 5;
```

</details>

#### 2) Create an output (`TxOut` object) to be included in our funding transaction

<details>
  <summary>Step 2 - More Info</summary>

A `build_output` function is available to you that takes an `amount` and `output_script` as an argument and produces a `TxOut` object that can be passed into a transaction.

**Note**: You will want to call `.to_p2wsh()` on your redeem script from step one either as you pass it in to `build_output` or before. This is because `.to_p2wsh()` will convert your redeem script into an output script! In other works, in the format `OP_0 <32 byte hash>`.

```rust
pub fn build_output(amount: u64, output_script: ScriptBuf) -> TxOut {
    
    TxOut {
        value: Amount::from_sat(amount),
        script_pubkey: output_script,
    }
}
```

Below is an example of how `build_output` could be used:

```rust
let output = build_output(500_000, output_script.to_p2wsh());
```


</details>

#### 3) Create a the funding transaction (`Transaction` object).

<details>
  <summary>Step 3 - More Info</summary>

To create a transaction, you can use the following helper function:

```rust
pub fn build_transaction(version: Version, locktime: LockTime, tx_ins: Vec<TxIn>, tx_outs: Vec<TxOut>) -> Transaction {
    Transaction {
        version: version,
        lock_time: locktime,
        input: tx_ins,
        output: tx_outs,
    }
}
```
### When building the transaction, note the following:

### Tx Outputs
`build_transaction` expects `tx_outs` to be a **vector** (think: list) of `TxOut` objects. To wrap your output in a vector, you can use the following syntax:

```rust
vec![output]
```

### Version & Locktime
When specifying the version and locktime, you can use the following syntax that rust-bitcoin provides. We'll learn about other varieties shortly, but this will help us get started.
- `Version::TWO`: Version 2 is post-BIP-68, which introduced sequence number relative locktimes. 
- `LockTime::ZERO`: This signals that there is no timelock on this transaction.

```rust
let version = Version::TWO;
let locktime = LockTime::ZERO;
```

</details>

## üëâ Get Our Funding Transaction
Now for the fun part! Once your `build_funding_transaction` is passing the tests, go to a **Shell** in your Repl and type in the below command.

```
cargo run --bin funding
```
This command is calling a function within `src/bin/funding.rs` which fetches a UTXO from our regtest wallet and sends it to a two-of-two multisig. Once you run it, you should see an output like this...

```
Tx ID:
8077cb7913e97caefb6199deeb1a14b4ecc740206f05cdfb56605da794ae0e8f

Tx Hex: 020000000001018d54238793c4547bb913e369a27c74bc08fc20c33197f5690f41565c7cfad12e0000000000ffffffff01784a4c0000000000220020657760ca015175e42ff5b4470563b23adcf0d2973a0506a176a5569690d64437024730440220548d3aeae38390d1d4f79b8756b5758d131051ddce223aa4f395bb88be1ccaeb02201698654ab9c29d41822771cd3a75bffec87488322a46783f64cd53aefb1f5d960121024e77786b0c8bef20ef469345cf4c306b14dee25dd5bab152155bee1e2115e93100000000
```

This is our funding transaction. **Note: we have NOT broadcasted this yet**. Go ahead and copy the **Tx Hex** and **Tx ID** and save them in the file `src/ch1_intro_htlcs/transactions.txt` under the headings **Funding Tx Hex** and **Funding Tx ID**. This is our funding transaction, but we need to wait to publish it!

## Problem: Potential Loss of Funds

How can Alice lose all of her funds in this setup?

<details>
  <summary>Answer</summary>

  If Bob stops responding or refuses to cooperate, then there's no way for Alice to retrieve her funds from this payment channel. This is because, to spend from a 2-of-2 multisig, you need signatures from *both* parties.
</details>


How can we address this problem for Alice?

<details>
  <summary>Answer</summary>

  There are a few different ways to go about this, but the general solution is that we will need to create a way for Alice to recieve a "refund" or unilateral exit from the channel. Can you think of how we can implement this?
</details>