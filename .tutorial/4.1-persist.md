# Persisting Data

We're making great progress on building our node, however, we're missing an important step. If our node goes offline or crashes, we need a way to get back online smoothly.

LDK provides an overall structure that defines what methods a persistence structure should implement, but it leaves the details up to the developer. For example, the developer can choose to save data in a cloud environment, local disk, any key-value database, or even a combination of these.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/node_setup/persistance.png" alt="persistance" width="100%" height="auto">
</p>

For this exercise, we'll configure our node to store data to our local Replit's file storage.

#### Question: What Needs to be Persisted?

<details>
  <summary>
    Answer
</summary>
    
- Channel monitors (for fund safety)
- Channel manager state
- Network graph (routing information)
- Scoring data (for routing decisions)
</details>


## KVStore
LDK provides a `KVStore` interface trait that defines methods to read, write, remove, and list key-value data within a data store. [You can read more about it here.](https://docs.rs/lightning/latest/lightning/util/persist/trait.KVStore.html)

The `KVStore` has the following four required methods:
- **read**: Retrieves data stored at the given namespaces and key, returning NotFound error if the key doesn't exist.
- **write**: Stores data at the given namespaces and key, creating namespaces if they don't exist.
- **remove**: Removes data at the given namespaces and key, with an option for lazy deletion; succeeds whether or not the key existed.
- **list**: Returns an unordered list of all keys stored under the given namespaces, returning empty list if namespaces don't exist.

When implementing this trait, we specify how we'd like to storage and retrieve our data. For example, in the cloud, local disk, etc.

## ⚡️ Implement `KVStore` For Our `SimpleStore`

To get a feel for how `KVStore` works, we'll implement it for `SimpleStore`. As the name suggests, `SimpleStore` will be *very* simple. It will just be a `HashMap` that stores raw bytes. A `HashMap` is a form of key-value storage within Rust. It's like a file cabinet where each file (value) has a unique label (key). If you're familiar with Python, you can think of it as a "dictionary". 

Within the `ch2_setup/persist_exercise.rs` file, you will see the `SimpleStore` struct. This defines a simple structure that stores a hashmap, where the key is a string and the value is a vector of bytes.
```rust
pub struct SimpleStore {
  data: RwLock<HashMap<String, Vec<u8>>>,
}
```

To implement LDK's `KVStore`, we'll complete the `read`, `write`, `remove`, and `list` functions so that they operate on our hashmap accordingly. When you're done, click "Run" and see if the `ch2_setup::test::test_SimpleStore` test passes.

```rust
impl KVStore for SimpleStore {
fn write(
  &self, primary_namespace: &str, secondary_namespace: &str, key: &str, buf: &[u8],
) -> Result<()> {
  todo!()
}

fn read(
  &self, primary_namespace: &str, secondary_namespace: &str, key: &str,
) -> Result<Vec<u8>> {
  todo!()
  }

fn remove(
    &self, primary_namespace: &str, secondary_namespace: &str, key: &str, lazy: bool,
  ) -> Result<()>{
  todo!()
  }

fn list(
    &self, primary_namespace: &str, secondary_namespace: &str,
  ) -> Result<Vec<String>> {
  todo!()
    }
}
```