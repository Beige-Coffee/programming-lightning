# Persisting Data

We're making great progress on building our node, however, we're missing an important step. If our node goes offline or crashes, we need a way to get back online smoothly.

As we've seen with past interfaces, LDK provides an overall structure that defines which methods a persistence structure should implement, but it leaves the details up to the developer. For example, the developer can choose to save data in a cloud environment, local disk, any key-value database, or even a combination of these.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/node_setup/persistance.png" alt="persistance" width="100%" height="auto">
</p>


#### Question: What data needs to be persisted so that our node can continue to operate if it were to go offline?

<details>
  <summary>
    Answer
</summary>
    
- Channel monitors (for fund safety)
- Channel manager state
- Network graph (routing information)
- Scoring data (for routing decisions)
</details>


## KVStore
LDK provides a `KVStore` interface trait that defines methods to read, write, remove, and list key-value data within a data store. Once implemented, the `KVStore` will handle persisting and updating data related to LDK components such as `ChannelMonitor`, `ChannelManager`, `NetworkGraph`, and `WriteableScore` (used for scoring peers to optimize routing).

```rust
pub trait KVStore {
    // Required methods
    fn read(&self, primary_namespace: &str, secondary_namespace: &str, key: &str,
    ) -> Result<Vec<u8>, Error>;
  
    fn write(&self, primary_namespace: &str, secondary_namespace: &str, key: &str, buf: &[u8],
    ) -> Result<(), Error>;
  
    fn remove(&self, primary_namespace: &str, secondary_namespace: &str, key: &str,
        lazy: bool,
    ) -> Result<(), Error>;
  
    fn list(&self, primary_namespace: &str, secondary_namespace: &str,
    ) -> Result<Vec<String>, Error>;
}
```

As you can see above, the `KVStore` has the following four required methods:
- **read**: Retrieves data stored at the given namespaces and key, returning NotFound error if the key doesn't exist.
- **write**: Stores data at the given namespaces and key, creating namespaces if they don't exist.
- **remove**: Removes data at the given namespaces and key, with an option for lazy deletion; succeeds whether or not the key existed.
- **list**: Returns an unordered list of all keys stored under the given namespaces, returning empty list if namespaces don't exist.

When implementing this trait, we specify how we'd like to storage and retrieve our data. For example, in the cloud, local disk, etc.

It's also worth noting that developers can provide custom storage logic by implementing the below traits themselves. However, there are default implementations of these within the `KVStore`, so it's not neccessary.

- `Persister`: This interface defines methods for persisting a `ChannelManager`, `NetworkGraph`, and `WriteableScore`.
- `Persist`: This interface defines methods for persisting `ChannelMonitor`.

For more information on each of the above interfaces, click the dropdowns below.

<details>
  <summary>
    Persister Interface
</summary>

The `Persister` interface defines methods for persisting a `ChannelManager`, `NetworkGraph`, and `WriteableScore`.

```rust
pub trait Persister<'a, CM: Deref, L: Deref, S: Deref>
where
    CM::Target: 'static + AChannelManager,
    L::Target: 'static + Logger,
    S::Target: WriteableScore<'a>,
{
    // Required methods
    fn persist_manager(&self, channel_manager: &CM) -> Result<(), Error>;
    fn persist_graph(
        &self,
        network_graph: &NetworkGraph<L>,
    ) -> Result<(), Error>;
    fn persist_scorer(&self, scorer: &S) -> Result<(), Error>;
}
```

</details>

<details>
  <summary>
    Persist Interface
</summary>

The `Persist` interface defines methods for persisting `ChannelMonitor`. This could mean writing once to disk, and/or uploading to one or more backup services.

Persistence can happen in one of two ways - synchronously completing before the trait method calls return or asynchronously in the background.

```rust
pub trait Persist<ChannelSigner: EcdsaChannelSigner> {
    // Required methods
    fn persist_new_channel(
        &self,
        channel_funding_outpoint: OutPoint,
        monitor: &ChannelMonitor<ChannelSigner>,
    ) -> ChannelMonitorUpdateStatus;
    fn update_persisted_channel(
        &self,
        channel_funding_outpoint: OutPoint,
        monitor_update: Option<&ChannelMonitorUpdate>,
        monitor: &ChannelMonitor<ChannelSigner>,
    ) -> ChannelMonitorUpdateStatus;
    fn archive_persisted_channel(&self, channel_funding_outpoint: OutPoint);
}
```
</details>




## ⚡️ Implement `KVStore` For Our `SimpleStore`

To get a feel for how `KVStore` works, we'll implement it for `SimpleStore`. As the name suggests, `SimpleStore` will be *very* simple. It will just be a `HashMap` that stores raw bytes. A `HashMap` is a form of key-value storage within Rust. It's like a file cabinet where each file (value) has a unique label (key). If you're familiar with Python, you can think of it as a "dictionary". 

Within the `ch2_setup/persist_exercise.rs` file, you will see the `SimpleStore` struct. This defines a simple structure that stores a hashmap, where the key is a string and the value is a vector of bytes.
```rust
pub struct SimpleStore {
  data: RwLock<HashMap<String, Vec<u8>>>,
}
```

To implement LDK's `KVStore`, we'll complete the `read`, `write`, `remove`, and `list` functions so that they operate on our hashmap accordingly. When you're done, click "Run" and see if the `ch2_setup::test::test_SimpleStore` test passes.

```rust
impl KVStore for SimpleStore {
fn write(
  &self, primary_namespace: &str, secondary_namespace: &str, key: &str, buf: &[u8],
) -> Result<()> {
  todo!()
}

fn read(
  &self, primary_namespace: &str, secondary_namespace: &str, key: &str,
) -> Result<Vec<u8>> {
  todo!()
  }

fn remove(
    &self, primary_namespace: &str, secondary_namespace: &str, key: &str, lazy: bool,
  ) -> Result<()>{
  todo!()
  }

fn list(
    &self, primary_namespace: &str, secondary_namespace: &str,
  ) -> Result<Vec<String>> {
  todo!()
    }
}
```