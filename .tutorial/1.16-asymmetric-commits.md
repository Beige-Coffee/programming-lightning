# Developing Our Penalty Mechanism

## Asymmetric Commitment Transactions 
Up until now, there is a pretty important detail that has been abstracted away from our commitment transactions. While you're probably itching to dig into advanced cryptography and punish some cheaters, it will make our lives much easier if we review this detail first.

In the actual Lightning Network, each party has their own version of ***each*** commitment transaction. They are mirror images of each other, but their output scripts are slightly different.

In the below example, you can see that both Alice and Bob's versions reflect the same distribution of funds, however, Alice's transaction provides a spending path for Bob to claim her funds if she attempts to cheat Bob - and vice versa.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/asym_pseudo.png" alt="asym_pseudo" width="100%" height="auto">
</p>

***NOTE***: The Lightning Network fairness protocol is setup up in such a way that **you protect your counterparty** from ***you*** cheating. This is why the output that has ***your*** balance contains the penalty mechanism, while the output with your counterparty's balance is a simple **P2WPKH**. Put simply, if you cheat, your opponent can steal ***your*** output immediately.

## Introducing Revocation Keys

Okay, now that we've reviewed asymmetric transactions, hopefully the penalty mechanism will seem more intuitive.

To bring our penalty mechanism to life, we'll start by adding a new public key to our output script. This public key will be called the **revocation public key**, and it's a very special public key for the following reasons:
1) Roughly speaking, it's created by combining **one public key from Alice** and **one public key from Bob**.
2) At the time of creating the public keys, neither Alice nor Bob know the private keys ***for either public key***.

**However**, when Alice and Bob decide to move to a new channel state, they will exchange the information needed for **each other** to calculate the ***other person's private key***. Neither will be able to calculate the private key ***for their own revocation public key***. 

This way, each party provides a way for the counterparty to claim their funds ***if and only if*** they attempt to publish an old transaction.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/revocation_keys_no_delay.png" alt="revocation_keys_no_delay" width="40%" height="auto">
</p>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/AsymCommits.png" alt="AsymCommits" width="100%" height="auto">
</p>


## Calculating A Revocation Public Key And Private Key

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/revocationSteps.png" alt="revocationSteps" width="100%" height="auto">
</p>

## ⚡️ Generate A Revocation Public Key
For this exercise, we'll get our hands dirty and implement a function that creates a revocation public key for a given channel state.
```rust
fn generate_revocation_pubkey(countersignatory_basepoint: &PublicKey, per_commitment_point: &PublicKey) -> PublicKey {
  
  // calculate `h1` by obtaining the SHA256 of `R` and `P` concatenated.
  
  // calculate `h2` by obtaining the SHA256 of `P` and `R` concatenated.
  
  // multiply `R` by `h1`. Remember, `R` is a public key and `h1` is a SHA256 hash, which will be interpreted as a scalar to "tweak" the public key.
  
  // multiply `P` by `h2`. Remember, `P` is a public key and `h2` is a SHA256 hash, which will be interpreted as a scalar to "tweak" the public key.
  
  // add the result of the two multiplications above. This is effectively adding two public keys together.
}
```

If you look at the diagram above, we'll be building a function that implements this step:

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/revocation_pubkey.png" alt="revocation_pubkey" width="50%" height="auto">
</p>

To do this, we'll need to get convert the above diagram into an equation that we can actually implement. This will get a little mathy, but don't worry! We'll step through it together. Below is the general equation for calculating a revocation public key.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/revocation_equation.png" alt="revocation_equation" width="50%" height="auto">
</p>

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/revocation_vals.png" alt="revocation_vals" width="50%" height="auto">
</p>

<details>
  <summary>Click for more details on each component in the equation</summary>

- **`R`** is the **remote party's revocation basepoint public key**. If Alice is calcuating the revocation public key for her transaction, then this will be Bob's revocation basepoint public key, which Bob gives to Alice when they set up the channel.
- **`P`** is **local party's per commitment public key**. Remember, this is a public key that is unique to every commitment transaction.
- **`h1`** is the SHA256 hash of both public keys. The **`||`** symbol means "concatenate". Therefore, to calculate **`h1`**, we serialize both keys, concatenate them together, and then take the hash of the result.
- **`h2`** is the SHA256 hash of both public keys, but in the opposite order as **`h1`**.
</details>

Here's a quick breakdown of the mathematical operations being performed in this equation:
1) **SHA256 Hashing**: The public keys **`R`** and **`P`** are concatenated together and hashed. These hashes (**`h1`** and **`h2`**) are treated as very large numbers (scalars) in subsequent operations.
2) **Elliptic Curve Multiplication (Tweaking)**: The public keys **`R`** and **`P`** are multiplied by the scalar representation of their respective hashes (i.e., the large numbers derived from hashing). This operation essentially adds the public key (**`R`** or **`P`**) to itself **`h1`** or **`h2`** times. This process is commonly referred to as **"tweaking"** a public key, as it modifies the original public key to produce a new one that depends on the scalar.
3) **Elliptic Curve Addition**: Finally, the tweaked public keys (**`R ⋅ h1 `** and **`P  ⋅ h2`**) are added together using elliptic curve point addition. The result is a new public key that is a unique combination of the original public keys and the hashes. This new key is cryptographically tied to both inputs and cannot be reverse-engineered without knowledge of the specific scalars used in tweaking.

Helper function have been provided to you to help perform each of the mathematical operations listed above.


```rust
pub fn hash_pubkeys(key1: &PublicKey, key2: &PublicKey) -> [u8; 32] {
  // Computes the SHA-256 hash of the two public keys
  // Returns a 32-byte array representing the hash of the concatenated serialized public keys.
}
```

```rust
pub fn tweak_pubkey(pubkey1: PublicKey, sha_bytes: [u8; 32]) -> PublicKey {
  // Multiplies a public key by a scalar derived from a 32-byte hash.
  // Returns the resulting public key after scalar multiplication.
}
```

```rust
pub fn add_pubkeys(key1: &PublicKey, key2: &PublicKey) -> Pubkey {
  // Adds two public keys.
  // Returns the resulting public key after addition.
  
}
```