# Refund the Channel

If Bob becomes unresponsive or stops cooperating with Alice, then Alice needs to have a backup plan so that she can retrieve her funds from the payment channel. 

## Approach 1: Use Multiple Spending Paths and Timelocks
One approach would be to **use multiple spending paths** and timelocks to ensure that the channel balance can be refunded to Alice if something goes wrong. 

The first spending path checks to see if both Aice's and Bob's signature are provided. If so, that is sufficient to satisfy the conditions on this output and spend the funds. Nice!

If not, we can check if a relative timelock has passed since this transaction was confirmed on chain. For example, we could add a condition that says, if 2016 blocks (~2 weeks) have passed since the funding transaction was confirmed, then Alice can spend this output to herself. **This would act as Alice "refunding" her channel balance.**

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/simple_funding.png" alt="simple_funding" width="100%" height="auto">
</p>

Once the funding transaction is confirmed, Alice can begin paying Bob by creating a new transactions with separate outputs for each of their balances. 

**Crucially, Alice will sign the transaction and send it to Bob, but Bob will not sign it yet**. This way, Alice cannot broadcast an old transaction, but Bob can decide to sign and close the channel when ready.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/simple_payment.png" alt="simple_payment" width="100%" height="auto">
</p>

While this is a valid approach to constructing a payment channel, is has some undesirable properties.

#### Question: What problem did the introduction of timelocks create?
<details>
  <summary>Answer</summary>
They gave our channels a limited lifetime. Bob must close the channel before the timelock expires otherwise Alice can take all of her funds back using the refund spending path.
</details>

We could build a payment channel off this construct where any new payment creates another transaction with the same properties as this transaction, but with a new channel balance.
#### Question: How come Bob cannot pay Alice using this channel?
<details>
  <summary>Answer</summary>
Under this channel construct, every time Alice pays Bob, a new transaction is created with their new channel balances.

While Alice, ***the sender***, signs the transactions, Bob, ***the reciever*** does not, thus guaranteeing Alice cannot publish any old transactions.
  
**However**, if Alice and Bob agreed to create a new transaction that pays Bob, there is nothing stopping Bob from publishing an older transaction that paid him more Bitcoin.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/simple_payment_issue.png" alt="simple_payment_issue" width="100%" height="auto">
</p>

</details>

#### Question: What if we used an absolute locktime instead of a relative locktime? How would that impact the end date of the channel?
<details>
  <summary>Answer</summary>
  
If we had used an absolute locktime (```OP_CLTV```) instead of a relative locktime (```OP_CSV```), then Alice's refund path would be spendable once a given block hieght OR timestamp is reached. This effectively means that Alice and Bob would have an estimated end-date for when they would want to close the channel. A relative timelock allows Alice and Bob to specify a more general time period, and the "clock" only starts ticking once the transaction is mined.
</details>
