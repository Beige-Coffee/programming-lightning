# Refund the Channel

If Bob becomes unresponsive or stops cooperating with Alice, then Alice needs to have a backup plan so that she can retrieve her funds from the payment channel. 

## Approach 1: Use Multiple Spending Paths and Timelocks
One approach would be to **use multiple spending paths** and timelocks to ensure that the channel balance can be refunded to Alice if something goes wrong. Take a minute to see if you can determine how this approach would be implemented in the **output script**.

<details>
  <summary>Answer</summary>
  <br/>

In this example, we create multiple spending paths. The first spending path checks to see if both Aice's and Bob's signature are provided. If so, that is sufficient to satisfy the conditions on this output and spend the funds. If not, we can check if a relative timelock has passed since this transaction was confirmed on chain. For example, we could add a condition that says, if 2016 blocks (~2 weeks) have passed since the funding transaction was confirmed, then Alice can spend this output to herself. This would act as Alice "refunding" her channel balance.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/intro_to_htlc/simple_funding_timelock.png" alt="simple_funding_timelock" width="100%" height="auto">
</p>

While a valid approach to ensuring Alice can get her funds out of the 2-of-2 funding transaction, this approach introduces some undesirable properties.

#### Question: What problem did the introduction of timelocks create?
<details>
  <summary>Answer</summary>
  <br/>
They gave our channels a limited lifetime. Bob must close the channel before the timelock expires otherwise Alice can take all of her funds back using the refund spending path.
</details>

We could build a payment channel off this construct where any new payment creates another transaction with the same properties as this transaction, but with a new channel balance.
#### Question: How come Bob cannot pay Alice using this channel?
<details>
  <summary>Answer</summary>
  <br/>
Under this new construct, every payment from Alice to Bob will be a new 2-of-2 multisig transaction with a timelocked refund to Alice. For example, imagine the following scenario:
  
- The channel starts with 5 bitcoin on Alice's side.
- Alice makes a payment to Bob of 2 bitcoin. Alice now has 3 bitcoin on her side.
- Bob makes a payment back to Alice for 1 bitcoin. Alice now has 4 bitcoin.
  
Since we cannot "cancel" old transactions, Bob can still broadcast the old channel state which pays him 2 bitcoin. To protect from this, the channel would have to be one-way from Alice to Bob.
</details>

#### Question: What if we used an absolute locktime instead of a relative locktime? How would that impact the end date of the channel?
<details>
  <summary>Answer</summary>
  <br/>
  
If we had used an absolute locktime (```OP_CLTV```) instead of a relative locktime (```OP_CSV```), then Alice's refund path would be spendable once a given block hieght OR timestamp is reached. This effectively means that Alice and Bob would have an estimated end-date for when they would want to close the channel. A relative timelock allows Alice and Bob to specify a more general time period, and the "clock" only starts ticking once the transaction is mined.
</details>

</details>
