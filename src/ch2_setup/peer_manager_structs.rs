#![allow(dead_code, unused_imports, unused_variables, unused_must_use)]
use crate::internal;
use lightning::ln::types::ChannelId;
use bitcoin::secp256k1::{self, Secp256k1, PublicKey};
use std::collections::HashMap;
use crate::ch3_keys::exercises::{
    SimpleKeysManager as KeysManager,
};
use internal::events::{Message};
use internal::events::MessageSendEvent;
use bitcoin::secp256k1::ecdsa::Signature;

#[derive(Clone, Debug)]
#[cfg_attr(test, derive(PartialEq))]
pub struct OpenChannel {
  pub channel_value_satoshis: u64
}

#[derive(Clone, Debug)]
#[cfg_attr(test, derive(PartialEq))]
pub struct AcceptChannel {
  pub channel_value_satoshis: u64
}

#[derive(Clone, Debug)]
#[cfg_attr(test, derive(PartialEq))]
pub struct FundingCreated {
  /// A temporary channel ID, until the funding is established
  pub temporary_channel_id: ChannelId,
  pub transaction_id: Txid
}

#[derive(Clone, Debug)]
#[cfg_attr(test, derive(PartialEq))]
pub struct FundingSigned {
  /// A temporary channel ID, until the funding is established
  pub channel_id: ChannelId,
  pub signature: Txid
}

#[derive(Clone, Debug)]
#[cfg_attr(test, derive(PartialEq))]
pub struct ChannelReady {
  /// A temporary channel ID, until the funding is established
  pub channel_id: ChannelId,
}


pub trait ChannelMessageHandler {
  fn handle_open_channel(&self, their_node_id: PublicKey, msg: &OpenChannel);
  /// Handle an incoming `open_channel2` message from the given peer.

  /// Handle an incoming `accept_channel` message from the given peer.
  fn handle_accept_channel(&self, their_node_id: PublicKey, msg: &AcceptChannel);

  /// Handle an incoming `funding_created` message from the given peer.
  fn handle_funding_created(&self, their_node_id: PublicKey, msg: &FundingCreated);

  /// Handle an incoming `funding_signed` message from the given peer.
  fn handle_funding_signed(&self, their_node_id: PublicKey, msg: &FundingSigned);

  /// Handle an incoming `channel_ready` message from the given peer.
  fn handle_channel_ready(&self, their_node_id: PublicKey, msg: &ChannelReady);
}

#[derive(Clone, Debug)]
#[cfg_attr(test, derive(PartialEq))]
pub struct NodeAnnouncement {
  /// A temporary channel ID, until the funding is established
  pub signature: Signature,
  pub contents: [u8],
}

#[derive(Clone, Debug, Hash, PartialEq, Eq)]
pub struct ChannelAnnouncement {
  /// Authentication of the announcement by the first public node
  pub node_signature_1: Signature,
  /// Authentication of the announcement by the second public node
  pub node_signature_2: Signature,
  /// Proof of funding UTXO ownership by the first public node
  pub bitcoin_signature_1: Signature,
  /// Proof of funding UTXO ownership by the second public node
  pub bitcoin_signature_2: Signature,
  /// The actual announcement
  pub contents: [u8],
}

pub trait RoutingMessageHandler {
  /// Handle an incoming `node_announcement` message, returning `true` if it should be forwarded on,
  /// `false` or returning an `Err` otherwise.
  ///
  /// If `their_node_id` is `None`, the message was generated by our own local node.
  fn handle_node_announcement(&self, their_node_id: Option<PublicKey>, msg: &NodeAnnouncement);
  /// Handle a `channel_announcement` message, returning `true` if it should be forwarded on, `false`
  /// or returning an `Err` otherwise.
  ///
  /// If `their_node_id` is `None`, the message was generated by our own local node.
  fn handle_channel_announcement(&self, their_node_id: Option<PublicKey>, msg: &ChannelAnnouncement);
}

#[derive(Clone, Debug, Hash, PartialEq, Eq)]
pub struct OnionMessage {
  /// Used in decrypting the onion packet's payload.
  pub blinding_point: PublicKey,
  /// The full onion packet including hop data, pubkey, and hmac
  pub onion_routing_packet: [u8],
}

/// A handler for received [`OnionMessage`]s and for providing generated ones to send.
pub trait OnionMessageHandler {
  /// Handle an incoming `onion_message` message from the given peer.
  fn handle_onion_message(&self, peer_node_id: PublicKey, msg: &OnionMessage);

pub struct MessageHandler {
  pub channel_message_handler: ChannelMessageHandler,
  pub routing_message_handler: RoutingMessageHandler,
  pub onion_message_handler: OnionMessageHandler
}


pub struct PeerManager{
  pub peers: HashMap<SocketDescriptor, Peer>,
  pub pending_msg_events: Vec<MessageSendEvent>,
  pub message_handler: MessageHandler,
  pub node_signer: KeysManager,
  pub secp_ctx: Secp256k1<secp256k1::SignOnly>
}